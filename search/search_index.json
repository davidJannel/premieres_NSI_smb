{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sp\u00e9cialit\u00e9 NSI \u2693\ufe0e Lyc\u00e9e Ste Marie - Beaucamps Ligny \u2693\ufe0e Supports utilis\u00e9s : \u2693\ufe0e Documents, activit\u00e9s, mini-projets, TP, \u00e9valuations : \u2693\ufe0e Moodle Cahier d'activit\u00e9 Bordas : \u2693\ufe0e Ressources en ligne du cahier Programme officiel \u2693\ufe0e Progression pour cette ann\u00e9e : \u2693\ufe0e CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine R\u00e9f\u00e9rences et sites utilis\u00e9s: \u2693\ufe0e","title":"Sp\u00e9cialit\u00e9 NSI"},{"location":"#specialite-nsi","text":"","title":"Sp\u00e9cialit\u00e9 NSI"},{"location":"#lycee-ste-marie-beaucamps-ligny","text":"","title":"Lyc\u00e9e Ste Marie - Beaucamps Ligny"},{"location":"#supports-utilises","text":"","title":"Supports utilis\u00e9s :"},{"location":"#documents-activites-mini-projets-tp-evaluations","text":"Moodle","title":"Documents, activit\u00e9s, mini-projets, TP, \u00e9valuations :"},{"location":"#cahier-dactivite-bordas","text":"Ressources en ligne du cahier","title":"Cahier d'activit\u00e9 Bordas :"},{"location":"#programme-officiel","text":"","title":"Programme officiel"},{"location":"#progression-pour-cette-annee","text":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine","title":"Progression pour cette ann\u00e9e :"},{"location":"#references-et-sites-utilises","text":"","title":"R\u00e9f\u00e9rences et sites utilis\u00e9s:"},{"location":"Architecture/sommaire/","text":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine CH3 : Syst\u00e8mes d'exploitation","title":"Sommaire"},{"location":"Architecture/IHM/cours/","text":"","title":"Cours"},{"location":"Architecture/OS/cours/","text":"CH3 : Syst\u00e8mes d'exploitation \u2693\ufe0e Programme officiel 1. Qu'est ce qu'un syst\u00e8me d'exploitation ? \u2693\ufe0e Un syst\u00e8me d\u2019exploitation ( OS pour \"op\u00e9rating system\" ) est un logiciel, ou ensemble de programmes, qui sert d\u2019interface entre les programmes ex\u00e9cut\u00e9s par l\u2019utilisateur et les ressources mat\u00e9rielles d\u2019un ordinateur. Il est \u00e0 la fois : une machine virtuelle qui pr\u00e9sente une interface simplifi\u00e9e d\u2019acc\u00e8s aux ressources (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d\u2019entr\u00e9e/sortie, r\u00e9seau \u2026) pour les autres programmes et pour l\u2019utilisateur un chef d\u2019orchestre et un administrateur : c\u2019est le premier programme ex\u00e9cut\u00e9 au d\u00e9marrage de l\u2019ordinateur il g\u00e8re l\u2019acc\u00e8s concurrent aux ressources par les diff\u00e9rents programmes (ordonnancement de l\u2019utilisation du processeur par les programmes en cours d\u2019ex\u00e9cution ou processus, s\u00e9curisation de la m\u00e9moire) ou utilisateurs (droits d\u2019acc\u00e8s du syst\u00e8me de fichiers). \u00c0 retenir Le syst\u00e8me d'exploitation est l'ensemble des programmes qui permet aux autres programmes d'interagir avec les ressources mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e / sortie) sur un ordinateur. Il sert donc d'interm\u00e9diaire entre le mat\u00e9riel et le logiciel et assure la coordination, la s\u00e9curit\u00e9 et la stabilit\u00e9 d'un environnement partag\u00e9s par plusieurs programmes et plusieurs utilisateurs. Les deux familles de syst\u00e8mes d'exploitation les plus populaires sont Unix (dont macOS , GNU/Linux , iOS et Android ) et Windows . Windows est principalement utilis\u00e9 sur les PC de bureau, c'est un syst\u00e8me d'exploitation propri\u00e9taire tout comme MacOS. Linux au contraire est un syst\u00e8me d'exploitation libre , il est principalement utilis\u00e9 dans les serveurs, t\u00e9l\u00e9phones portables via Android et les supercalculateurs. Comme nous avons au lyc\u00e9e un syst\u00e8me d'exploitation Windows et que le programme officiel demande de travailler sous Linux, vous pouvez passer les commandes de ce chapitre directement dans le navigateur gr\u00e2ce \u00e0 l'\u00e9mulateur de syst\u00e8me mis au point par Fabrice Bellard accessible \u00e0 l'adresse : https://bellard.org/jslinux/vm.html?url=alpine-x86.cfg&mem=192 2. Syst\u00e8me de fichier de Linux \u2693\ufe0e 2.1 Arborescence \u2693\ufe0e Avec Linux , comme dans Windows, les donn\u00e9es sont stock\u00e9es dans des fichiers ( file :gb), eux-m\u00eames contenus dans des dossiers appell\u00e9s r\u00e9pertoires ( directory ). Contrairement \u00e0 Windows, sous Linux, la notion de \"disque\" n'existe pas. L'organisation des r\u00e9pertoires et fichiers est appell\u00e9e arborescence . Sous Linux, tout est fichier. Ils sont organis\u00e9s suivant une unique arborescence dont la racine est nomm\u00e9e / . Les r\u00e9pertoires n\u00e9cessaires au fonctionnement du syt\u00e8me d'exploitation sont etc, dev, tmp ... . Les r\u00e9pertoires des utilisateurs sont situ\u00e9s dans le r\u00e9pertoire home 2.2 Chemin d'un fichier \u2693\ufe0e Pour localiser un fichier dans cette arborescence on doit d\u00e9finir le chemin d'acc\u00e8s au fichier. a. Chemin absolu \u2693\ufe0e \u00c0 savoir Le chemin absolu d'un fichier est part toujours du r\u00e9pertoire racine : / suivi du ou des nom(s) de r\u00e9pertoire(s) jusqu'\u00e0 la destination, s\u00e9par\u00e9 par des symboles / . Exemple : Dans l'arborescence ci-dessous, le chemin absolu du fichier fibonacci.py est /home/frederic/programmes/fibonacci.py Attention Linux est sensible \u00e0 la casse : majuscules, minuscules, espaces ... b. Chemin relatif \u2693\ufe0e \u00c0 savoir Lorsqu'on se d\u00e9place dans le syst\u00e8me de fichier, le r\u00e9pertoire dans lequel on se trouve s'appelle le r\u00e9pertoire courant . Un chemin relatif part du r\u00e9pertoire courant et donne la liste des noms du ou des r\u00e9pertoire(s) jusqu'\u00e0 la destination, s\u00e9par\u00e9s par des / . Dans un chemin relatif . signifie r\u00e9pertoire (ou n\u0153ud) courant , .. signifie r\u00e9petoire (ou n\u0153ud) parent , ~ signifie r\u00e9pertoire personnel . Exemples : Dans l'arborescence pr\u00e9c\u00e9dente, si on est dans son r\u00e9pertoire personnel frederic , le chemin relatif du fichier fibonacci.py est ./fibonacci.py . Par contre, si on se situe dans le r\u00e9pertoire images , le chemin relatif du fichier fibonacci.py est ../programmes/fibonacci.py . 3. Interface utilisateur d\u2019un syst\u00e8me d\u2019exploitation \u2693\ufe0e 3.1 Le shell \u2693\ufe0e Une interface entre l\u2019utilisateur et le syst\u00e8me d\u2019exploitation s\u2019appelle un shell ou interpr\u00e9teur de commandes . Le r\u00f4le d\u2019un shell est de prendre une entr\u00e9e de l\u2019utilisateur, de la traduire en instructions compr\u00e9hensibles par le syst\u00e8me d\u2019exploitation et de renvoyer la r\u00e9ponse du syst\u00e8me \u00e0 l\u2019utilisateur. Il existe deux grandes cat\u00e9gories de shell : les interfaces textuelles comme bash , le plus commun sur les syst\u00e8mes de la famille UNIX. les interfaces graphiques qu\u2019on retrouve dans les syst\u00e8mes d\u2019exploitation grand public tels que Windows 3.2 Invite de commande et commandes \u2693\ufe0e On appelle Invite de commande le message qui \u00ab invite \u00bb \u00e0 entrer une commande dans la console/terminal. Exemple : toto@pc12_lycee:~$ toto@pc_lycee d\u00e9signe le nom de l' utilisateur toto sur la machine nomm\u00e9e pc12_lycee . Le signe ~ signifie que l'on se trouve dans le r\u00e9pertoire personnel de l'utilisateur toto . Le symbole dollar $ final signifie que l\u2019utilisateur toto n\u2019est pas l\u2019administrateur de la machine . Lorsqu\u2019on utilise la machine en tant qu\u2019 administrateur , appel\u00e9 root sous UniX, le symbole terminal est # . La syntaxe d'une ligne commande est : nom de la commande suivi \u00e9ventuellement d' -options et d' arguments . Exemple : toto@pc12_lycee:~$ rm -r ./Documents/Dossier_secret La commande est rm . On a une option -r et un argument ./Documents/Dossier_secret . Cela signifie que l'on veut supprimer le r\u00e9pertoire Dossier_secret et tout ce qu'il contient. 3.3 Commandes de base Linux \u2693\ufe0e On prendra pour exemple l'arborescence de fichier ci-dessous pour illustrer nos exemples. On est l'utilisateur sophie . a. Naviger dans le syst\u00e8me de fichiers \u2693\ufe0e pwd (print working directory) : Affiche le nom du r\u00e9pertoire courant. ls (list) : Permet d'afficher le contenu d'un r\u00e9pertoire. cd destination (change directory) : permet de changer de r\u00e9pertoire courant. Exemple : sophie@ma_machine:~$ pwd /home/sophie sophie@ma_machine:~$ ls images sophie@ma_machine:~$ cd ./images sophie@ma_machine:images$ ls noel2018 photo2.jpg b. Cr\u00e9er des r\u00e9pertoires \u2693\ufe0e mkdir nom_repertoire (make directory) : cr\u00e9e un r\u00e9pertoire nom_repertoire . Exemple : sophie@ma_machine:images$ mkdir vacances2022 sophie@ma_machine:images$ ls noel2018 vacances2022 photo2.jpg c. D\u00e9placer / Copier des fichiers \u2693\ufe0e mv source destination (move) : d\u00e9place ou renomme le fichier ou repertoire source en destination . cp source destination (copy) : copie le fichier ou r\u00e9pertoire source vers la destination . Exemple : sophie@ma_machine:images$ mv photo2.jpg ./vacances2022/montagne.jpg sophie@ma_machine:images$ ls noel2018 vacances2022 sophie@ma_machine:images$ cd ./vacances2022 sophie@ma_machine:vacances2022$ ls montagne.jpg sophie@ma_machine:vacances2022$ cp ../noel2018/photo1.jpg ./ sophie@ma_machine:vacances2022$ ls montagne.jpg photo1.jpg d. Supprimer des fichiers et des r\u00e9pertoires \u2693\ufe0e rm chemin/nom_fichier (remove) : supprime le fichier nom_fichier . rm -r chemin/nom_repertoire : supprime le r\u00e9pertoire nom_repertoire et tout ce qu'il contient. Exemple : sophie@ma_machine:vacances2022$ rm -r ../noel2018 sophie@ma_machine:vacances2022$ cd .. sophie@ma_machine:image$ cd ./noel2018 bash: cd: ./noel2018 No such file or directory e. D'autres commandes utiles \u2693\ufe0e man nom_commande (manual) : acc\u00e9s \u00e0 la documentation de la commande nom_commande . clear (clear) : efface le contenu du terminal. history (history) : affiche l'historique des commandes pass\u00e9es. 4. Droits et permissions \u2693\ufe0e 4.1 Utilisateurs et groupes sous Linux \u2693\ufe0e Un syst\u00e8me Linux peut \u00eatre utilis\u00e9 par plusieurs utilisateurs. Un utilisateur est identifi\u00e9 sur une machine par un identifiant ( user id ) et poss\u00e8de un espace de travail personnel avec un r\u00e9pertoire courant. Tous les utilisateurs n'ont pas forc\u00e9ment les m\u00eames droits d'acc\u00e8s et les m\u00eames permissions d'acc\u00e8s aux fichiers et r\u00e9pertoires de la machine. Les droits et permissions sont g\u00e9r\u00e9s par le syst\u00e8me d'exploitation. L' administrateur ou Le super utilisateur (super user ) appell\u00e9 root a acc\u00e8s \u00e0 tous les fichiers et r\u00e9pertoires du syst\u00e8me. Il a tous les droits. La commande sudo (Super-User DO) permet d'ex\u00e9cuter une commande en mode root dans un Terminal. Pour que la commande puisse \u00eatre pass\u00e9e, il faut alors taper le mot de passe administrateur. Le propri\u00e9taire d'un fichier est l'utilisateur qui l'a cr\u00e9\u00e9. Le propri\u00e9taire d'un fichier ou d'un r\u00e9pertoire peut modifier les droits. Le super utilisateur peut \u00e9galement le faire et il peut m\u00eame changer le propri\u00e9taire. Chaque utilisateur appartient \u00e0 un ou plusieurs groupes . Ces groupes permettent de rassembler les utilisateurs qui ont les m\u00eame droits. 4.2 Droits des r\u00e9pertoires et fichiers \u2693\ufe0e Chaque fichier et chaque r\u00e9pertoire poss\u00e8de une liste de droits : c\u2019est une liste qui indique qui a le droit de lire le fichier ( read ), de le modifier ( write ) et de l\u2019 ex\u00e9cuter ( execute ) ; on y a acc\u00e8s \u00e0 l\u2019aide de la commande ls -l . 4.3 G\u00e9rer les droits \u2693\ufe0e Un utilisateur a le droit de faire un chmod (change mode ) sur un fichier ou un r\u00e9pertoire afin de modifier les droits : s'il est root ; ou s'il est le propri\u00e9taire du fichier ou du r\u00e9pertoire en question. Les options pass\u00e9es \u00e0 la commande chmod sont indiqu\u00e9es comme ceci : chmod options modes fichiers Pour un fichier : chmod [u g o a] [+ - =] [r w x] nom_du_fichier Pour le contenu d'un r\u00e9pertoire (de fa\u00e7on r\u00e9cursive) : chmod -R [u g o a] [+ - =] [r w x] nom_du_r\u00e9pertoire Les lett res u g o a designe les types de propri\u00e9taires** concern\u00e9s: u propri\u00e9taire (user) g groupe (group) o les autres (others) a tous (all) Les lettres + - = d\u00e9signent les changements d'\u00e9tat : + et - pour ajouter ou retirer un type de droit aux droits courants, et l'op\u00e9rateur = pour les \u00e9craser. Les lettres r w x d\u00e9signent les permissions : read, write, execute . Exemple d'utilisation avec le syst\u00e8me de fichier utilis\u00e9 dans les exemples pr\u00e9c\u00e9dents : Sophie propri\u00e9taire d'un fichier jeu.py situ\u00e9 dans le r\u00e9pertoire NSI . Elle a les droits de lecture, d'\u00e9criture et d'execution. Les utilisateurs ,appartenant au m\u00eame groupe que Sophie, ont les droits de lecture mais ceux de d'\u00e9criture et d'execution. Les autres utilisateurs n'ont aucun droits. On peut visualiser \u00e7a avec la commande ls -l . sophie@ma_machine:NSI$ ls -l total 28 -rwxr----- 1 sophie sophie 2690 15 sept. 10 :39 jeu.py Elle souhaite ajouter les droits d'execution aux personnes faisant partie de son groupe sans leur donner la possibilit\u00e9 de modifier (d'\u00e9crire) dans le fichier et uniquement les droits de lecture aux autres. sophie@ma_machine:NSI$ chmod g+x,o+r jeu.py sophie@ma_machine:NSI$ ls -l total 28 -rwxr-xr-- 1 sophie sophie 2690 15 sept. 10 :39 jeu.py La virgule permet de faire plusieurs modifications dans la m\u00eame commande 4.4 Notation octale \u2693\ufe0e Pour modifier toutes les permission d'une seule commande, on utilise la notation octale (On reviendra sur cette partie un peu plus tard dans l'ann\u00e9e).","title":"CH3 : Syst\u00e8mes d'exploitation"},{"location":"Architecture/OS/cours/#ch3-systemes-dexploitation","text":"Programme officiel","title":"CH3 : Syst\u00e8mes d'exploitation"},{"location":"Architecture/OS/cours/#1-quest-ce-quun-systeme-dexploitation","text":"Un syst\u00e8me d\u2019exploitation ( OS pour \"op\u00e9rating system\" ) est un logiciel, ou ensemble de programmes, qui sert d\u2019interface entre les programmes ex\u00e9cut\u00e9s par l\u2019utilisateur et les ressources mat\u00e9rielles d\u2019un ordinateur. Il est \u00e0 la fois : une machine virtuelle qui pr\u00e9sente une interface simplifi\u00e9e d\u2019acc\u00e8s aux ressources (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d\u2019entr\u00e9e/sortie, r\u00e9seau \u2026) pour les autres programmes et pour l\u2019utilisateur un chef d\u2019orchestre et un administrateur : c\u2019est le premier programme ex\u00e9cut\u00e9 au d\u00e9marrage de l\u2019ordinateur il g\u00e8re l\u2019acc\u00e8s concurrent aux ressources par les diff\u00e9rents programmes (ordonnancement de l\u2019utilisation du processeur par les programmes en cours d\u2019ex\u00e9cution ou processus, s\u00e9curisation de la m\u00e9moire) ou utilisateurs (droits d\u2019acc\u00e8s du syst\u00e8me de fichiers). \u00c0 retenir Le syst\u00e8me d'exploitation est l'ensemble des programmes qui permet aux autres programmes d'interagir avec les ressources mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e / sortie) sur un ordinateur. Il sert donc d'interm\u00e9diaire entre le mat\u00e9riel et le logiciel et assure la coordination, la s\u00e9curit\u00e9 et la stabilit\u00e9 d'un environnement partag\u00e9s par plusieurs programmes et plusieurs utilisateurs. Les deux familles de syst\u00e8mes d'exploitation les plus populaires sont Unix (dont macOS , GNU/Linux , iOS et Android ) et Windows . Windows est principalement utilis\u00e9 sur les PC de bureau, c'est un syst\u00e8me d'exploitation propri\u00e9taire tout comme MacOS. Linux au contraire est un syst\u00e8me d'exploitation libre , il est principalement utilis\u00e9 dans les serveurs, t\u00e9l\u00e9phones portables via Android et les supercalculateurs. Comme nous avons au lyc\u00e9e un syst\u00e8me d'exploitation Windows et que le programme officiel demande de travailler sous Linux, vous pouvez passer les commandes de ce chapitre directement dans le navigateur gr\u00e2ce \u00e0 l'\u00e9mulateur de syst\u00e8me mis au point par Fabrice Bellard accessible \u00e0 l'adresse : https://bellard.org/jslinux/vm.html?url=alpine-x86.cfg&mem=192","title":"1. Qu'est ce qu'un syst\u00e8me d'exploitation ?"},{"location":"Architecture/OS/cours/#2-systeme-de-fichier-de-linux","text":"","title":"2. Syst\u00e8me de fichier de Linux"},{"location":"Architecture/OS/cours/#21-arborescence","text":"Avec Linux , comme dans Windows, les donn\u00e9es sont stock\u00e9es dans des fichiers ( file :gb), eux-m\u00eames contenus dans des dossiers appell\u00e9s r\u00e9pertoires ( directory ). Contrairement \u00e0 Windows, sous Linux, la notion de \"disque\" n'existe pas. L'organisation des r\u00e9pertoires et fichiers est appell\u00e9e arborescence . Sous Linux, tout est fichier. Ils sont organis\u00e9s suivant une unique arborescence dont la racine est nomm\u00e9e / . Les r\u00e9pertoires n\u00e9cessaires au fonctionnement du syt\u00e8me d'exploitation sont etc, dev, tmp ... . Les r\u00e9pertoires des utilisateurs sont situ\u00e9s dans le r\u00e9pertoire home","title":"2.1 Arborescence"},{"location":"Architecture/OS/cours/#22-chemin-dun-fichier","text":"Pour localiser un fichier dans cette arborescence on doit d\u00e9finir le chemin d'acc\u00e8s au fichier.","title":"2.2 Chemin d'un fichier"},{"location":"Architecture/OS/cours/#3-interface-utilisateur-dun-systeme-dexploitation","text":"","title":"3. Interface utilisateur d\u2019un syst\u00e8me d\u2019exploitation"},{"location":"Architecture/OS/cours/#31-le-shell","text":"Une interface entre l\u2019utilisateur et le syst\u00e8me d\u2019exploitation s\u2019appelle un shell ou interpr\u00e9teur de commandes . Le r\u00f4le d\u2019un shell est de prendre une entr\u00e9e de l\u2019utilisateur, de la traduire en instructions compr\u00e9hensibles par le syst\u00e8me d\u2019exploitation et de renvoyer la r\u00e9ponse du syst\u00e8me \u00e0 l\u2019utilisateur. Il existe deux grandes cat\u00e9gories de shell : les interfaces textuelles comme bash , le plus commun sur les syst\u00e8mes de la famille UNIX. les interfaces graphiques qu\u2019on retrouve dans les syst\u00e8mes d\u2019exploitation grand public tels que Windows","title":"3.1 Le shell"},{"location":"Architecture/OS/cours/#32-invite-de-commande-et-commandes","text":"On appelle Invite de commande le message qui \u00ab invite \u00bb \u00e0 entrer une commande dans la console/terminal. Exemple : toto@pc12_lycee:~$ toto@pc_lycee d\u00e9signe le nom de l' utilisateur toto sur la machine nomm\u00e9e pc12_lycee . Le signe ~ signifie que l'on se trouve dans le r\u00e9pertoire personnel de l'utilisateur toto . Le symbole dollar $ final signifie que l\u2019utilisateur toto n\u2019est pas l\u2019administrateur de la machine . Lorsqu\u2019on utilise la machine en tant qu\u2019 administrateur , appel\u00e9 root sous UniX, le symbole terminal est # . La syntaxe d'une ligne commande est : nom de la commande suivi \u00e9ventuellement d' -options et d' arguments . Exemple : toto@pc12_lycee:~$ rm -r ./Documents/Dossier_secret La commande est rm . On a une option -r et un argument ./Documents/Dossier_secret . Cela signifie que l'on veut supprimer le r\u00e9pertoire Dossier_secret et tout ce qu'il contient.","title":"3.2 Invite de commande et commandes"},{"location":"Architecture/OS/cours/#33-commandes-de-base-linux","text":"On prendra pour exemple l'arborescence de fichier ci-dessous pour illustrer nos exemples. On est l'utilisateur sophie .","title":"3.3 Commandes de base Linux"},{"location":"Architecture/OS/cours/#4-droits-et-permissions","text":"","title":"4. Droits et permissions"},{"location":"Architecture/OS/cours/#41-utilisateurs-et-groupes-sous-linux","text":"Un syst\u00e8me Linux peut \u00eatre utilis\u00e9 par plusieurs utilisateurs. Un utilisateur est identifi\u00e9 sur une machine par un identifiant ( user id ) et poss\u00e8de un espace de travail personnel avec un r\u00e9pertoire courant. Tous les utilisateurs n'ont pas forc\u00e9ment les m\u00eames droits d'acc\u00e8s et les m\u00eames permissions d'acc\u00e8s aux fichiers et r\u00e9pertoires de la machine. Les droits et permissions sont g\u00e9r\u00e9s par le syst\u00e8me d'exploitation. L' administrateur ou Le super utilisateur (super user ) appell\u00e9 root a acc\u00e8s \u00e0 tous les fichiers et r\u00e9pertoires du syst\u00e8me. Il a tous les droits. La commande sudo (Super-User DO) permet d'ex\u00e9cuter une commande en mode root dans un Terminal. Pour que la commande puisse \u00eatre pass\u00e9e, il faut alors taper le mot de passe administrateur. Le propri\u00e9taire d'un fichier est l'utilisateur qui l'a cr\u00e9\u00e9. Le propri\u00e9taire d'un fichier ou d'un r\u00e9pertoire peut modifier les droits. Le super utilisateur peut \u00e9galement le faire et il peut m\u00eame changer le propri\u00e9taire. Chaque utilisateur appartient \u00e0 un ou plusieurs groupes . Ces groupes permettent de rassembler les utilisateurs qui ont les m\u00eame droits.","title":"4.1 Utilisateurs et groupes sous Linux"},{"location":"Architecture/OS/cours/#42-droits-des-repertoires-et-fichiers","text":"Chaque fichier et chaque r\u00e9pertoire poss\u00e8de une liste de droits : c\u2019est une liste qui indique qui a le droit de lire le fichier ( read ), de le modifier ( write ) et de l\u2019 ex\u00e9cuter ( execute ) ; on y a acc\u00e8s \u00e0 l\u2019aide de la commande ls -l .","title":"4.2 Droits des r\u00e9pertoires et fichiers"},{"location":"Architecture/OS/cours/#43-gerer-les-droits","text":"Un utilisateur a le droit de faire un chmod (change mode ) sur un fichier ou un r\u00e9pertoire afin de modifier les droits : s'il est root ; ou s'il est le propri\u00e9taire du fichier ou du r\u00e9pertoire en question. Les options pass\u00e9es \u00e0 la commande chmod sont indiqu\u00e9es comme ceci : chmod options modes fichiers Pour un fichier : chmod [u g o a] [+ - =] [r w x] nom_du_fichier Pour le contenu d'un r\u00e9pertoire (de fa\u00e7on r\u00e9cursive) : chmod -R [u g o a] [+ - =] [r w x] nom_du_r\u00e9pertoire Les lett res u g o a designe les types de propri\u00e9taires** concern\u00e9s: u propri\u00e9taire (user) g groupe (group) o les autres (others) a tous (all) Les lettres + - = d\u00e9signent les changements d'\u00e9tat : + et - pour ajouter ou retirer un type de droit aux droits courants, et l'op\u00e9rateur = pour les \u00e9craser. Les lettres r w x d\u00e9signent les permissions : read, write, execute . Exemple d'utilisation avec le syst\u00e8me de fichier utilis\u00e9 dans les exemples pr\u00e9c\u00e9dents : Sophie propri\u00e9taire d'un fichier jeu.py situ\u00e9 dans le r\u00e9pertoire NSI . Elle a les droits de lecture, d'\u00e9criture et d'execution. Les utilisateurs ,appartenant au m\u00eame groupe que Sophie, ont les droits de lecture mais ceux de d'\u00e9criture et d'execution. Les autres utilisateurs n'ont aucun droits. On peut visualiser \u00e7a avec la commande ls -l . sophie@ma_machine:NSI$ ls -l total 28 -rwxr----- 1 sophie sophie 2690 15 sept. 10 :39 jeu.py Elle souhaite ajouter les droits d'execution aux personnes faisant partie de son groupe sans leur donner la possibilit\u00e9 de modifier (d'\u00e9crire) dans le fichier et uniquement les droits de lecture aux autres. sophie@ma_machine:NSI$ chmod g+x,o+r jeu.py sophie@ma_machine:NSI$ ls -l total 28 -rwxr-xr-- 1 sophie sophie 2690 15 sept. 10 :39 jeu.py La virgule permet de faire plusieurs modifications dans la m\u00eame commande","title":"4.3 G\u00e9rer les droits"},{"location":"Architecture/OS/cours/#44-notation-octale","text":"Pour modifier toutes les permission d'une seule commande, on utilise la notation octale (On reviendra sur cette partie un peu plus tard dans l'ann\u00e9e).","title":"4.4 Notation octale"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/","text":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine \u2693\ufe0e Programme officiel 1. Les constituants d'une machine \u2693\ufe0e 1.1 D\u00e9monter un ordinateur \u2693\ufe0e 1.2 Constituants et p\u00e9riph\u00e9riques d'un ordinateur \u2693\ufe0e Le micro-ordinateur est traditionnellement compos\u00e9 d\u2019une unit\u00e9 centrale (unit\u00e9 de traitement de l\u2019information), essentiellement un microprocesseur , ainsi que d\u2019 interfaces d\u2019entr\u00e9e (clavier, souris, etc.) et d\u2019 interfaces de sortie (\u00e9cran, imprimante, etc\u2026). Les \u00e9l\u00e9ments pr\u00e9sents sur l'image ci-dessus sont : L\u2019 \u00e9cran : affiche les informations (texte, image, vid\u00e9o, \u2026) La carte m\u00e8re : regroupe les principaux circuits de l\u2019ordinateur Le microprocesseur : ex\u00e9cute les instructions des programmes Les connecteurs pour p\u00e9riph\u00e9riques (disques durs, \u2026) La m\u00e9moire vive (RAM) : stocke momentan\u00e9ment les donn\u00e9es et les programmes Les cartes d\u2019extension : ajoutent des fonctionnalit\u00e9s \u00e0 l\u2019ordinateur (ports, TV, vid\u00e9o, \u2026) L\u2019 alimentation : fournit aux divers composants une \u00e9nergie \u00e9lectrique r\u00e9gul\u00e9e Le(s) lecteur(s)/graveurs(s) optique(s) : CD, DVD, \u2026 Le(s) disque(s) dur(s) : stocke de fa\u00e7on durable les donn\u00e9es et les programmes Le clavier : permet la saisie de caract\u00e8res, \u2026 La souris : permet le pointage d\u2019\u00e9l\u00e9ments sur l\u2019\u00e9cran 2. Le mod\u00e8le d'architecture de Von Neumann \u2693\ufe0e 2.1 Un peu d'histoire \u2693\ufe0e Vid\u00e9o du cours Lumni 2.2 L'architecture de Von Neumann \u2693\ufe0e On \u00e9tudiera en fin d'ann\u00e9e le fonctionnement de cette architecture. Mais pour l'instant on va retenir que les \u00e9l\u00e9ments essentiels d'un ordinateur sont : l\u2019 unit\u00e9 arithm\u00e9tique et logique ( UAL) ou unit\u00e9 de traitement : elle effectue tous les calculs que peut r\u00e9aliser le microprocesseur. l\u2019 unit\u00e9 de contr\u00f4le : elle effectue le \u00ab s\u00e9quen\u00e7age des op\u00e9rations \u00bb en envoyant les ordres \u00e0 l\u2019UAL la m\u00e9moire : elle contient \u00e0 la fois les donn\u00e9es et les programmes. les dispositifs d\u2019entr\u00e9es-sorties : ils permettent de communiquer avec l\u2019ext\u00e9rieur. 2.3 C'est quoi le microprocesseur (CPU) ? \u2693\ufe0e Il est constitu\u00e9 de 3 parties : L\u2019 unit\u00e9 arithm\u00e9tique et logique L\u2019 unit\u00e9 de commande Les registres , qui permettent de m\u00e9moriser de l\u2019information temporairement. 2.4 La m\u00e9moire \u2693\ufe0e La m\u00e9moire permet de stocker des donn\u00e9es et des programmes, elle se divise entre : m\u00e9moire volatile (programmes et donn\u00e9es en cours de fonctionnement, effac\u00e9s lorsque l\u2019alimentation est coup\u00e9e) m\u00e9moire permanente (programmes et donn\u00e9es de base de la machine) Diff\u00e9rents types de m\u00e9moire sont utilis\u00e9s dans un ordinateur : 2.5 Les bus \u2693\ufe0e Le syst\u00e8me permettant la circulation des donn\u00e9es entre les parties de l\u2019ordinateur est appel\u00e9 bus . Il existe 3 grands types de bus : Le bus d\u2019adresses permet de faire circuler des adresses. Le bus de donn\u00e9es permet de faire circuler des donn\u00e9es. Le bus de contr\u00f4le permet de sp\u00e9cifier le type d\u2019action.","title":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#ch1-constituants-et-peripheriques-dune-machine","text":"Programme officiel","title":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#1-les-constituants-dune-machine","text":"","title":"1. Les constituants d'une machine"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#11-demonter-un-ordinateur","text":"","title":"1.1 D\u00e9monter un ordinateur"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#12-constituants-et-peripheriques-dun-ordinateur","text":"Le micro-ordinateur est traditionnellement compos\u00e9 d\u2019une unit\u00e9 centrale (unit\u00e9 de traitement de l\u2019information), essentiellement un microprocesseur , ainsi que d\u2019 interfaces d\u2019entr\u00e9e (clavier, souris, etc.) et d\u2019 interfaces de sortie (\u00e9cran, imprimante, etc\u2026). Les \u00e9l\u00e9ments pr\u00e9sents sur l'image ci-dessus sont : L\u2019 \u00e9cran : affiche les informations (texte, image, vid\u00e9o, \u2026) La carte m\u00e8re : regroupe les principaux circuits de l\u2019ordinateur Le microprocesseur : ex\u00e9cute les instructions des programmes Les connecteurs pour p\u00e9riph\u00e9riques (disques durs, \u2026) La m\u00e9moire vive (RAM) : stocke momentan\u00e9ment les donn\u00e9es et les programmes Les cartes d\u2019extension : ajoutent des fonctionnalit\u00e9s \u00e0 l\u2019ordinateur (ports, TV, vid\u00e9o, \u2026) L\u2019 alimentation : fournit aux divers composants une \u00e9nergie \u00e9lectrique r\u00e9gul\u00e9e Le(s) lecteur(s)/graveurs(s) optique(s) : CD, DVD, \u2026 Le(s) disque(s) dur(s) : stocke de fa\u00e7on durable les donn\u00e9es et les programmes Le clavier : permet la saisie de caract\u00e8res, \u2026 La souris : permet le pointage d\u2019\u00e9l\u00e9ments sur l\u2019\u00e9cran","title":"1.2 Constituants et p\u00e9riph\u00e9riques d'un ordinateur"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#2-le-modele-darchitecture-de-von-neumann","text":"","title":"2. Le mod\u00e8le d'architecture de Von Neumann"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#21-un-peu-dhistoire","text":"Vid\u00e9o du cours Lumni","title":"2.1 Un peu d'histoire"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#22-larchitecture-de-von-neumann","text":"On \u00e9tudiera en fin d'ann\u00e9e le fonctionnement de cette architecture. Mais pour l'instant on va retenir que les \u00e9l\u00e9ments essentiels d'un ordinateur sont : l\u2019 unit\u00e9 arithm\u00e9tique et logique ( UAL) ou unit\u00e9 de traitement : elle effectue tous les calculs que peut r\u00e9aliser le microprocesseur. l\u2019 unit\u00e9 de contr\u00f4le : elle effectue le \u00ab s\u00e9quen\u00e7age des op\u00e9rations \u00bb en envoyant les ordres \u00e0 l\u2019UAL la m\u00e9moire : elle contient \u00e0 la fois les donn\u00e9es et les programmes. les dispositifs d\u2019entr\u00e9es-sorties : ils permettent de communiquer avec l\u2019ext\u00e9rieur.","title":"2.2 L'architecture de Von Neumann"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#23-cest-quoi-le-microprocesseur-cpu","text":"Il est constitu\u00e9 de 3 parties : L\u2019 unit\u00e9 arithm\u00e9tique et logique L\u2019 unit\u00e9 de commande Les registres , qui permettent de m\u00e9moriser de l\u2019information temporairement.","title":"2.3 C'est quoi le microprocesseur (CPU) ?"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#24-la-memoire","text":"La m\u00e9moire permet de stocker des donn\u00e9es et des programmes, elle se divise entre : m\u00e9moire volatile (programmes et donn\u00e9es en cours de fonctionnement, effac\u00e9s lorsque l\u2019alimentation est coup\u00e9e) m\u00e9moire permanente (programmes et donn\u00e9es de base de la machine) Diff\u00e9rents types de m\u00e9moire sont utilis\u00e9s dans un ordinateur :","title":"2.4 La m\u00e9moire"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#25-les-bus","text":"Le syst\u00e8me permettant la circulation des donn\u00e9es entre les parties de l\u2019ordinateur est appel\u00e9 bus . Il existe 3 grands types de bus : Le bus d\u2019adresses permet de faire circuler des adresses. Le bus de donn\u00e9es permet de faire circuler des donn\u00e9es. Le bus de contr\u00f4le permet de sp\u00e9cifier le type d\u2019action.","title":"2.5 Les bus"},{"location":"Architecture/Von%20Neumann%20partie%202/cours/","text":"","title":"Cours"},{"location":"Types%20bases/Booleens/cours/","text":"CH2 : Les op\u00e9rateurs bool\u00e9ens \u2693\ufe0e Programme officiel 1. Le calcul bool\u00e9en \u2693\ufe0e 1.1 Un peu d'histoire \u2693\ufe0e En 1847, le britannique George BOOLE inventa un formalisme permettant d'\u00e9crire des raisonnements logiques : l' alg\u00e8bre de Boole . La notion m\u00eame d'informatique n'existait pas \u00e0 l'\u00e9poque, m\u00eame si les calculs \u00e9taient d\u00e9j\u00e0 automatis\u00e9s (penser \u00e0 la Pascaline de 1642). Bien plus tard, en 1938, les travaux de l'am\u00e9ricain Claude SHANNON prouva que des circuits \u00e9lectriques peuvent r\u00e9soudre tous les probl\u00e8mes que l'alg\u00e8bre de Boole peut elle-m\u00eame r\u00e9soudre. Pendant la deuxi\u00e8me guerre mondiale, les travaux d' Alan TURING puis de John VON NEUMANN poseront d\u00e9finitivement les bases de l'informatique moderne. 1.2 Variable bool\u00e9enne \u2693\ufe0e \u00c0 savoir Une variable bool\u00e9enne est une variable qui ne peut prendre que deux valeurs possibles : Vrai ( True ) ou 1 Faux ( False ) ou 0 Une variable bool\u00e9enne en Python est du type bool . >>> a = False >>> print ( type ( a )) < class ' bool '> Remarque : Ouvert/Ferm\u00e9 (interrupteur), Allum\u00e9/\u00c9teint (lampe), 5V/0V (tension), Blanc/Noir (pixels d'une image noir et blanc) ... sont \u00e9galement des variables bool\u00e9ennes. 1.3 Op\u00e9rateurs bool\u00e9ens \u2693\ufe0e Un op\u00e9rateur bool\u00e9en est un op\u00e9rateur math\u00e9matique qui manipule des variables bool\u00e9ennes. Une expression bool\u00e9enne est une expression dont le r\u00e9sultat est un bool\u00e9en. Un op\u00e9rande est un \u00e9l\u00e9ment sur lequel on applique un op\u00e9rateur bool\u00e9en. a. L'op\u00e9rateur not \u2693\ufe0e \u00c0 conna\u00eetre L'op\u00e9rateur not (\"non\" ) est l'op\u00e9rateur de n\u00e9gation : si on note a la variable d'entr\u00e9e, not a ou \\(\\mathrm{\\overline{a}}\\) renvoie la n\u00e9gation de a. Table de v\u00e9rit\u00e9 de not a not a 0 1 1 0 En python >>> a = True >>> print ( not a ) False >>> b = not a >>> print ( not b ) True b. L'op\u00e9rateur and \u2693\ufe0e \u00c0 conna\u00eetre L'op\u00e9rateur and (\"et\" ) est un op\u00e9rateur de conjonction . Si a et b sont deux variables bool\u00e9ennes, a and b renvoie Vrai si a et b sont Vrai toutes les deux, et Faux sinon. La table de v\u00e9rit\u00e9 de and a b a and b 0 0 0 0 1 0 1 0 0 1 1 1 En python >>> a = True >>> b = True >>> c = False >>> print ( a and b ) True >>> print ( c and b ) False c. L'op\u00e9rateur or \u2693\ufe0e \u00c0 conna\u00eetre L'op\u00e9rateur or (\"ou\" ) est un op\u00e9rateur de disjonction . Si a et b sont deux variables bool\u00e9ennes, a or b renvoie Vrai quand au moins un des deux op\u00e9randes a ou b sont Vrai, et Faux sinon. La table de v\u00e9rit\u00e9 de or a b a or b 0 0 0 0 1 1 1 0 1 1 1 1 En python >>> a = True >>> b = True >>> c = False >>> d = False >>> print ( a or b ) True >>> print ( c or b ) True >>> print ( d or c ) False d. L'op\u00e9rateur xor \u2693\ufe0e \u00c0 savoir L'op\u00e9rateur xor (\"ou exclusif\" ) est un op\u00e9rateur de disjonction exclusive . Si a et b sont deux variables bool\u00e9ennes, a xor b renvoie Vrai un seul des deux op\u00e9randes a ou b sont Vrai, et Faux sinon. La table de v\u00e9rit\u00e9 de xor a b a xor b 0 0 0 0 1 1 1 0 1 1 1 0 1.4 \u00c9valuation d'une expression bool\u00e9enne \u2693\ufe0e \u00c0 conna\u00eetre Il faut faire comme en math\u00e9matique. On doit tenir compte de la priorit\u00e9 des op\u00e9rations et des parenth\u00e8ses. Le not est prioritaire devant and qui lui-m\u00eame est prioritaire devant or ou xor . Expression comportant uniquement des valeurs bool\u00e9ennes \u2693\ufe0e Exemple : A = True and True or (not False and False) On commence par la parenth\u00e8se ( not False devient True puis True and False devient False : A = True and True or (True and False) = True and True or False Puis and est prioritaire devant or (donc True and True devient True ): A = True or False On a enfin A = True Expression comportant des variables bool\u00e9ennes \u2693\ufe0e Pour \u00e9valuer l'expression, on peut \u00e9tablir une table de v\u00e9rit\u00e9 . Il faut faire la table de v\u00e9rit\u00e9 de chaque partie de l'expression en tenant compte des r\u00e8gles pr\u00e9c\u00e9dentes. Exemple de l'expression a or not b : a b not b a or not b 0 0 1 1 0 1 0 0 1 0 1 1 1 1 0 1 1.5 Les expressions bool\u00e9ennes et python \u2693\ufe0e Les op\u00e9rateurs bool\u00e9ens \u2693\ufe0e Remarque 1 : \u2693\ufe0e Les op\u00e9rateurs bool\u00e9ens sont not , and et or . Ne pas confondre avec les op\u00e9rateurs de comparaison qui renvoient une valeur bool\u00e9enne. >>> 4 // 2 == 3 False >>> ( 7 > 3 ) and ( 9 != 8 ) and not False True Dans ces deux exemples == , > , != sont des op\u00e9rateurs de comparaison qui renvoient un bool\u00e9en. Remarque 2 : \u2693\ufe0e Python pratique l' \u00e9valuation paresseuse (short-circuit evaluation ). L'\u00e9valuation paresseuse le fait que l'interpr\u00e9teur Python s'arr\u00eate d\u00e8s que sa d\u00e9cision est prise. Exemple : >>> ( 20 // 2 == 8 ) and ( 20 // 4 == 5 ) False Comme le premier bool\u00e9en vaut False et que la conjonction and est appel\u00e9e, il n'est pas n\u00e9cessaire d'\u00e9valuer le deuxi\u00e8me bool\u00e9en. Essayez de lancer dans le terminal ci-dessous : False and print(\"Salut\") et comparez le \u00e0 True and print(\"Salut\") . Comparez ensuite avec l'op\u00e9rateur or . >>> 2. De l'expression bool\u00e9enne au composant \u00e9lectronique \u2693\ufe0e 2.1 Un peu d'histoire \u2693\ufe0e Les circuits d\u2019un ordinateur manipulent uniquement des 0 ou des 1 repr\u00e9sent\u00e9s en interne par des tensions hautes ou basses . Les premiers ordinateurs construits dans la p\u00e9riode 1945-1950 sont bas\u00e9s sur une technologie de tube \u00e0 vide ou tube \u00e9lectrique . En 1947, aux laboratoires Bell, Shockley, Bardeen et Brattain inventent le transistor , un petit composant \u00e9lectronique qui se comporte comme un interrupteur. Les transistors, plus petits et dissipant moins de chaleur, vont supplanter les tubes \u00e9lectriques. En 1954 le germanium est remplac\u00e9 par le silicium, en 1955 apparaissent les premiers ordinateurs enti\u00e8rement transistoris\u00e9s. En 1960 le transistor \u00e0 effet de champ permet l\u2019int\u00e9gration de dizaines composants dans un centim\u00e8tre carr\u00e9. Les transistors sont ensuite directement grav\u00e9s dans une plaque de silicium constituant un cicrcuit int\u00e9gr\u00e9 . En 1965, Gordon Moore futur directeur d\u2019Intel \u00e9nonce la loi empirique suivante : il y aura doublement de la densit\u00e9 d\u2019int\u00e9gration des transistors tous les deux ans. Cette loi s\u2019est v\u00e9rifi\u00e9e jusqu\u2019\u00e0 pr\u00e9sent avec une finesse de gravure d\u2019environ 5 nanom\u00e8tres en 2020. Le graphique ci-dessous repr\u00e9sente l\u2019\u00e9volution du nombre de transistors par circuit int\u00e9gr\u00e9. 2.2 Les portes logiques \u2693\ufe0e Dans un ordinateur, les op\u00e9rations de calcul sont effectu\u00e9es en binaire, \u00e0 l'aide de portes logiques . En associant des transistors, on r\u00e9alise ces portes logiques. Une porte logique est un circuit \u00e9lectronique repr\u00e9sentant une fonction logique. Voici ci-dessous la repr\u00e9sentation de quelques portes (repr\u00e9sentation am\u00e9ricaine et internationnale) 2.3 Circuit combinatoire \u2693\ufe0e Un circuit logique combinatoire permet de r\u00e9aliser une ou plusieurs fonctions bool\u00e9ennes : ses sorties ne d\u00e9pendent que de l'\u00e9tat actuel de ses entr\u00e9es. Les portes logiques NOT, NOR, NAND, AND, OR et XOR sont des circuits combinatoires. Exemple Que fait ce circuit ? Aide : Simuler en ligne Solution D\u00e9terminer la fonction logique r\u00e9aliser par ce circuit. R\u00e9aliser des circuits logiques et les tester ici On a r\u00e9alis\u00e9 une porte xor . Vous pouvez v\u00e9rifier que (a and not b) or (not a and b) = a xor b Il existe d'autres circuits, dits s\u00e9quentiels , dont les sorties se calculent non seulement \u00e0 partir de leurs valeurs d\u2019entr\u00e9e actuelles mais aussi \u00e0 partir de leurs \u00e9tats pr\u00e9c\u00e9dents : le facteur temps intervient. Ils utilisent des circuits de m\u00e9moire pour m\u00e9moriser leurs \u00e9tats ant\u00e9rieurs.","title":"CH2 : Les op\u00e9rateurs bool\u00e9ens"},{"location":"Types%20bases/Booleens/cours/#ch2-les-operateurs-booleens","text":"Programme officiel","title":"CH2 : Les op\u00e9rateurs bool\u00e9ens"},{"location":"Types%20bases/Booleens/cours/#1-le-calcul-booleen","text":"","title":"1. Le calcul bool\u00e9en"},{"location":"Types%20bases/Booleens/cours/#11-un-peu-dhistoire","text":"En 1847, le britannique George BOOLE inventa un formalisme permettant d'\u00e9crire des raisonnements logiques : l' alg\u00e8bre de Boole . La notion m\u00eame d'informatique n'existait pas \u00e0 l'\u00e9poque, m\u00eame si les calculs \u00e9taient d\u00e9j\u00e0 automatis\u00e9s (penser \u00e0 la Pascaline de 1642). Bien plus tard, en 1938, les travaux de l'am\u00e9ricain Claude SHANNON prouva que des circuits \u00e9lectriques peuvent r\u00e9soudre tous les probl\u00e8mes que l'alg\u00e8bre de Boole peut elle-m\u00eame r\u00e9soudre. Pendant la deuxi\u00e8me guerre mondiale, les travaux d' Alan TURING puis de John VON NEUMANN poseront d\u00e9finitivement les bases de l'informatique moderne.","title":"1.1 Un peu d'histoire"},{"location":"Types%20bases/Booleens/cours/#12-variable-booleenne","text":"\u00c0 savoir Une variable bool\u00e9enne est une variable qui ne peut prendre que deux valeurs possibles : Vrai ( True ) ou 1 Faux ( False ) ou 0 Une variable bool\u00e9enne en Python est du type bool . >>> a = False >>> print ( type ( a )) < class ' bool '> Remarque : Ouvert/Ferm\u00e9 (interrupteur), Allum\u00e9/\u00c9teint (lampe), 5V/0V (tension), Blanc/Noir (pixels d'une image noir et blanc) ... sont \u00e9galement des variables bool\u00e9ennes.","title":"1.2 Variable bool\u00e9enne"},{"location":"Types%20bases/Booleens/cours/#13-operateurs-booleens","text":"Un op\u00e9rateur bool\u00e9en est un op\u00e9rateur math\u00e9matique qui manipule des variables bool\u00e9ennes. Une expression bool\u00e9enne est une expression dont le r\u00e9sultat est un bool\u00e9en. Un op\u00e9rande est un \u00e9l\u00e9ment sur lequel on applique un op\u00e9rateur bool\u00e9en.","title":"1.3 Op\u00e9rateurs bool\u00e9ens"},{"location":"Types%20bases/Booleens/cours/#14-evaluation-dune-expression-booleenne","text":"\u00c0 conna\u00eetre Il faut faire comme en math\u00e9matique. On doit tenir compte de la priorit\u00e9 des op\u00e9rations et des parenth\u00e8ses. Le not est prioritaire devant and qui lui-m\u00eame est prioritaire devant or ou xor .","title":"1.4 \u00c9valuation d'une expression bool\u00e9enne"},{"location":"Types%20bases/Booleens/cours/#15-les-expressions-booleennes-et-python","text":"","title":"1.5 Les expressions bool\u00e9ennes et python"},{"location":"Types%20bases/Booleens/cours/#2-de-lexpression-booleenne-au-composant-electronique","text":"","title":"2. De l'expression bool\u00e9enne au composant \u00e9lectronique"},{"location":"Types%20bases/Booleens/cours/#21-un-peu-dhistoire","text":"Les circuits d\u2019un ordinateur manipulent uniquement des 0 ou des 1 repr\u00e9sent\u00e9s en interne par des tensions hautes ou basses . Les premiers ordinateurs construits dans la p\u00e9riode 1945-1950 sont bas\u00e9s sur une technologie de tube \u00e0 vide ou tube \u00e9lectrique . En 1947, aux laboratoires Bell, Shockley, Bardeen et Brattain inventent le transistor , un petit composant \u00e9lectronique qui se comporte comme un interrupteur. Les transistors, plus petits et dissipant moins de chaleur, vont supplanter les tubes \u00e9lectriques. En 1954 le germanium est remplac\u00e9 par le silicium, en 1955 apparaissent les premiers ordinateurs enti\u00e8rement transistoris\u00e9s. En 1960 le transistor \u00e0 effet de champ permet l\u2019int\u00e9gration de dizaines composants dans un centim\u00e8tre carr\u00e9. Les transistors sont ensuite directement grav\u00e9s dans une plaque de silicium constituant un cicrcuit int\u00e9gr\u00e9 . En 1965, Gordon Moore futur directeur d\u2019Intel \u00e9nonce la loi empirique suivante : il y aura doublement de la densit\u00e9 d\u2019int\u00e9gration des transistors tous les deux ans. Cette loi s\u2019est v\u00e9rifi\u00e9e jusqu\u2019\u00e0 pr\u00e9sent avec une finesse de gravure d\u2019environ 5 nanom\u00e8tres en 2020. Le graphique ci-dessous repr\u00e9sente l\u2019\u00e9volution du nombre de transistors par circuit int\u00e9gr\u00e9.","title":"2.1 Un peu d'histoire"},{"location":"Types%20bases/Booleens/cours/#22-les-portes-logiques","text":"Dans un ordinateur, les op\u00e9rations de calcul sont effectu\u00e9es en binaire, \u00e0 l'aide de portes logiques . En associant des transistors, on r\u00e9alise ces portes logiques. Une porte logique est un circuit \u00e9lectronique repr\u00e9sentant une fonction logique. Voici ci-dessous la repr\u00e9sentation de quelques portes (repr\u00e9sentation am\u00e9ricaine et internationnale)","title":"2.2 Les portes logiques"},{"location":"Types%20bases/Booleens/cours/#23-circuit-combinatoire","text":"Un circuit logique combinatoire permet de r\u00e9aliser une ou plusieurs fonctions bool\u00e9ennes : ses sorties ne d\u00e9pendent que de l'\u00e9tat actuel de ses entr\u00e9es. Les portes logiques NOT, NOR, NAND, AND, OR et XOR sont des circuits combinatoires. Exemple Que fait ce circuit ? Aide : Simuler en ligne Solution D\u00e9terminer la fonction logique r\u00e9aliser par ce circuit. R\u00e9aliser des circuits logiques et les tester ici On a r\u00e9alis\u00e9 une porte xor . Vous pouvez v\u00e9rifier que (a and not b) or (not a and b) = a xor b Il existe d'autres circuits, dits s\u00e9quentiels , dont les sorties se calculent non seulement \u00e0 partir de leurs valeurs d\u2019entr\u00e9e actuelles mais aussi \u00e0 partir de leurs \u00e9tats pr\u00e9c\u00e9dents : le facteur temps intervient. Ils utilisent des circuits de m\u00e9moire pour m\u00e9moriser leurs \u00e9tats ant\u00e9rieurs.","title":"2.3 Circuit combinatoire"},{"location":"xtra/end_REM/","text":"Z","title":"end REM"},{"location":"xtra/start_REM/","text":"A","title":"start REM"}]}