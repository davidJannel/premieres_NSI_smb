{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sp\u00e9cialit\u00e9 NSI \u2693\ufe0e Lyc\u00e9e Ste Marie - Beaucamps Ligny \u2693\ufe0e Supports utilis\u00e9s : \u2693\ufe0e Documents, activit\u00e9s, mini-projets, TP, \u00e9valuations : \u2693\ufe0e Moodle Cahier d'activit\u00e9 Bordas : \u2693\ufe0e Ressources en ligne du cahier Programme officiel \u2693\ufe0e Progression pour cette ann\u00e9e : \u2693\ufe0e CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine CH2 : Les op\u00e9rateurs bool\u00e9ens CH3 : Syst\u00e8mes d'exploitation CH4 : Constructions \u00e9l\u00e9mentaires CH5 : p-uplets CH6 : \u00c9crire un entier positifs dans une base sup\u00e9rieure ou \u00e9gale \u00e0 2 CH7 : Tableaux","title":"<center>Sp\u00e9cialit\u00e9 NSI</center>"},{"location":"#specialite-nsi","text":"","title":"Sp\u00e9cialit\u00e9 NSI"},{"location":"#lycee-ste-marie-beaucamps-ligny","text":"","title":"Lyc\u00e9e Ste Marie - Beaucamps Ligny"},{"location":"#supports-utilises","text":"","title":"Supports utilis\u00e9s :"},{"location":"#documents-activites-mini-projets-tp-evaluations","text":"Moodle","title":"Documents, activit\u00e9s, mini-projets, TP, \u00e9valuations :"},{"location":"#cahier-dactivite-bordas","text":"Ressources en ligne du cahier","title":"Cahier d'activit\u00e9 Bordas :"},{"location":"#programme-officiel","text":"","title":"Programme officiel"},{"location":"#progression-pour-cette-annee","text":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine CH2 : Les op\u00e9rateurs bool\u00e9ens CH3 : Syst\u00e8mes d'exploitation CH4 : Constructions \u00e9l\u00e9mentaires CH5 : p-uplets CH6 : \u00c9crire un entier positifs dans une base sup\u00e9rieure ou \u00e9gale \u00e0 2 CH7 : Tableaux","title":"Progression pour cette ann\u00e9e :"},{"location":"Architecture/sommaire/","text":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine CH3 : Syst\u00e8mes d'exploitation","title":"Sommaire"},{"location":"Architecture/IHM/cours/","text":"","title":"Cours"},{"location":"Architecture/OS/cours/","text":"CH3 : Syst\u00e8mes d'exploitation \u2693\ufe0e Programme officiel 1. Qu'est ce qu'un syst\u00e8me d'exploitation ? \u2693\ufe0e Un syst\u00e8me d\u2019exploitation ( OS pour \"op\u00e9rating system\" ) est un logiciel, ou ensemble de programmes, qui sert d\u2019interface entre les programmes ex\u00e9cut\u00e9s par l\u2019utilisateur et les ressources mat\u00e9rielles d\u2019un ordinateur. Il est \u00e0 la fois : une machine virtuelle qui pr\u00e9sente une interface simplifi\u00e9e d\u2019acc\u00e8s aux ressources (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d\u2019entr\u00e9e/sortie, r\u00e9seau \u2026) pour les autres programmes et pour l\u2019utilisateur un chef d\u2019orchestre et un administrateur : c\u2019est le premier programme ex\u00e9cut\u00e9 au d\u00e9marrage de l\u2019ordinateur il g\u00e8re l\u2019acc\u00e8s concurrent aux ressources par les diff\u00e9rents programmes (ordonnancement de l\u2019utilisation du processeur par les programmes en cours d\u2019ex\u00e9cution ou processus, s\u00e9curisation de la m\u00e9moire) ou utilisateurs (droits d\u2019acc\u00e8s du syst\u00e8me de fichiers). \u00c0 retenir Le syst\u00e8me d'exploitation est l'ensemble des programmes qui permet aux autres programmes d'interagir avec les ressources mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e / sortie) sur un ordinateur. Il sert donc d'interm\u00e9diaire entre le mat\u00e9riel et le logiciel et assure la coordination, la s\u00e9curit\u00e9 et la stabilit\u00e9 d'un environnement partag\u00e9s par plusieurs programmes et plusieurs utilisateurs. Les deux familles de syst\u00e8mes d'exploitation les plus populaires sont Unix (dont macOS , GNU/Linux , iOS et Android ) et Windows . Windows est principalement utilis\u00e9 sur les PC de bureau, c'est un syst\u00e8me d'exploitation propri\u00e9taire tout comme MacOS. Linux au contraire est un syst\u00e8me d'exploitation libre , il est principalement utilis\u00e9 dans les serveurs, t\u00e9l\u00e9phones portables via Android et les supercalculateurs. Comme nous avons au lyc\u00e9e un syst\u00e8me d'exploitation Windows et que le programme officiel demande de travailler sous Linux, vous pouvez passer les commandes de ce chapitre directement dans le navigateur gr\u00e2ce \u00e0 l'\u00e9mulateur de syst\u00e8me mis au point par Fabrice Bellard accessible \u00e0 l'adresse : https://bellard.org/jslinux/vm.html?url=alpine-x86.cfg&mem=192 2. Syst\u00e8me de fichier de Linux \u2693\ufe0e 2.1 Arborescence \u2693\ufe0e Avec Linux , comme dans Windows, les donn\u00e9es sont stock\u00e9es dans des fichiers ( file :gb), eux-m\u00eames contenus dans des dossiers appell\u00e9s r\u00e9pertoires ( directory ). Contrairement \u00e0 Windows, sous Linux, la notion de \"disque\" n'existe pas. L'organisation des r\u00e9pertoires et fichiers est appell\u00e9e arborescence . Sous Linux, tout est fichier. Ils sont organis\u00e9s suivant une unique arborescence dont la racine est nomm\u00e9e / . Les r\u00e9pertoires n\u00e9cessaires au fonctionnement du syt\u00e8me d'exploitation sont etc, dev, tmp ... . Les r\u00e9pertoires des utilisateurs sont situ\u00e9s dans le r\u00e9pertoire home 2.2 Chemin d'un fichier \u2693\ufe0e Pour localiser un fichier dans cette arborescence on doit d\u00e9finir le chemin d'acc\u00e8s au fichier. a. Chemin absolu \u2693\ufe0e \u00c0 savoir Le chemin absolu d'un fichier est part toujours du r\u00e9pertoire racine : / suivi du ou des nom(s) de r\u00e9pertoire(s) jusqu'\u00e0 la destination, s\u00e9par\u00e9 par des symboles / . Exemple : Dans l'arborescence ci-dessous, le chemin absolu du fichier fibonacci.py est /home/frederic/programmes/fibonacci.py Attention Linux est sensible \u00e0 la casse : majuscules, minuscules, espaces ... b. Chemin relatif \u2693\ufe0e \u00c0 savoir Lorsqu'on se d\u00e9place dans le syst\u00e8me de fichier, le r\u00e9pertoire dans lequel on se trouve s'appelle le r\u00e9pertoire courant . Un chemin relatif part du r\u00e9pertoire courant et donne la liste des noms du ou des r\u00e9pertoire(s) jusqu'\u00e0 la destination, s\u00e9par\u00e9s par des / . Dans un chemin relatif . signifie r\u00e9pertoire (ou n\u0153ud) courant , .. signifie r\u00e9petoire (ou n\u0153ud) parent , ~ signifie r\u00e9pertoire personnel . Exemples : Dans l'arborescence pr\u00e9c\u00e9dente, si on est dans son r\u00e9pertoire personnel frederic , le chemin relatif du fichier fibonacci.py est ./fibonacci.py . Par contre, si on se situe dans le r\u00e9pertoire images , le chemin relatif du fichier fibonacci.py est ../programmes/fibonacci.py . 3. Interface utilisateur d\u2019un syst\u00e8me d\u2019exploitation \u2693\ufe0e 3.1 Le shell \u2693\ufe0e Une interface entre l\u2019utilisateur et le syst\u00e8me d\u2019exploitation s\u2019appelle un shell ou interpr\u00e9teur de commandes . Le r\u00f4le d\u2019un shell est de prendre une entr\u00e9e de l\u2019utilisateur, de la traduire en instructions compr\u00e9hensibles par le syst\u00e8me d\u2019exploitation et de renvoyer la r\u00e9ponse du syst\u00e8me \u00e0 l\u2019utilisateur. Il existe deux grandes cat\u00e9gories de shell : les interfaces textuelles comme bash , le plus commun sur les syst\u00e8mes de la famille UNIX. les interfaces graphiques qu\u2019on retrouve dans les syst\u00e8mes d\u2019exploitation grand public tels que Windows 3.2 Invite de commande et commandes \u2693\ufe0e On appelle Invite de commande le message qui \u00ab invite \u00bb \u00e0 entrer une commande dans la console/terminal. Exemple : toto@pc12_lycee:~$ toto@pc_lycee d\u00e9signe le nom de l' utilisateur toto sur la machine nomm\u00e9e pc12_lycee . Le signe ~ signifie que l'on se trouve dans le r\u00e9pertoire personnel de l'utilisateur toto . Le symbole dollar $ final signifie que l\u2019utilisateur toto n\u2019est pas l\u2019administrateur de la machine . Lorsqu\u2019on utilise la machine en tant qu\u2019 administrateur , appel\u00e9 root sous UniX, le symbole terminal est # . La syntaxe d'une ligne commande est : nom de la commande suivi \u00e9ventuellement d' -options et d' arguments . Exemple : toto@pc12_lycee:~$ rm -r ./Documents/Dossier_secret La commande est rm . On a une option -r et un argument ./Documents/Dossier_secret . Cela signifie que l'on veut supprimer le r\u00e9pertoire Dossier_secret et tout ce qu'il contient. 3.3 Commandes de base Linux \u2693\ufe0e On prendra pour exemple l'arborescence de fichier ci-dessous pour illustrer nos exemples. On est l'utilisateur sophie . a. Naviger dans le syst\u00e8me de fichiers \u2693\ufe0e pwd (print working directory) : Affiche le nom du r\u00e9pertoire courant. ls (list) : Permet d'afficher le contenu d'un r\u00e9pertoire. cd destination (change directory) : permet de changer de r\u00e9pertoire courant. Exemple : sophie@ma_machine:~$ pwd /home/sophie sophie@ma_machine:~$ ls images sophie@ma_machine:~$ cd ./images sophie@ma_machine:images$ ls noel2018 photo2.jpg b. Cr\u00e9er des r\u00e9pertoires \u2693\ufe0e mkdir nom_repertoire (make directory) : cr\u00e9e un r\u00e9pertoire nom_repertoire . Exemple : sophie@ma_machine:images$ mkdir vacances2022 sophie@ma_machine:images$ ls noel2018 vacances2022 photo2.jpg c. D\u00e9placer / Copier des fichiers \u2693\ufe0e mv source destination (move) : d\u00e9place ou renomme le fichier ou repertoire source en destination . cp source destination (copy) : copie le fichier ou r\u00e9pertoire source vers la destination . Exemple : sophie@ma_machine:images$ mv photo2.jpg ./vacances2022/montagne.jpg sophie@ma_machine:images$ ls noel2018 vacances2022 sophie@ma_machine:images$ cd ./vacances2022 sophie@ma_machine:vacances2022$ ls montagne.jpg sophie@ma_machine:vacances2022$ cp ../noel2018/photo1.jpg ./ sophie@ma_machine:vacances2022$ ls montagne.jpg photo1.jpg d. Supprimer des fichiers et des r\u00e9pertoires \u2693\ufe0e rm chemin/nom_fichier (remove) : supprime le fichier nom_fichier . rm -r chemin/nom_repertoire : supprime le r\u00e9pertoire nom_repertoire et tout ce qu'il contient. Exemple : sophie@ma_machine:vacances2022$ rm -r ../noel2018 sophie@ma_machine:vacances2022$ cd .. sophie@ma_machine:image$ cd ./noel2018 bash: cd: ./noel2018 No such file or directory e. D'autres commandes utiles \u2693\ufe0e man nom_commande (manual) : acc\u00e9s \u00e0 la documentation de la commande nom_commande . clear (clear) : efface le contenu du terminal. history (history) : affiche l'historique des commandes pass\u00e9es. 4. Droits et permissions \u2693\ufe0e 4.1 Utilisateurs et groupes sous Linux \u2693\ufe0e Un syst\u00e8me Linux peut \u00eatre utilis\u00e9 par plusieurs utilisateurs. Un utilisateur est identifi\u00e9 sur une machine par un identifiant ( user id ) et poss\u00e8de un espace de travail personnel avec un r\u00e9pertoire courant. Tous les utilisateurs n'ont pas forc\u00e9ment les m\u00eames droits d'acc\u00e8s et les m\u00eames permissions d'acc\u00e8s aux fichiers et r\u00e9pertoires de la machine. Les droits et permissions sont g\u00e9r\u00e9s par le syst\u00e8me d'exploitation. L' administrateur ou Le super utilisateur (super user ) appell\u00e9 root a acc\u00e8s \u00e0 tous les fichiers et r\u00e9pertoires du syst\u00e8me. Il a tous les droits. La commande sudo (Super-User DO) permet d'ex\u00e9cuter une commande en mode root dans un Terminal. Pour que la commande puisse \u00eatre pass\u00e9e, il faut alors taper le mot de passe administrateur. Le propri\u00e9taire d'un fichier est l'utilisateur qui l'a cr\u00e9\u00e9. Le propri\u00e9taire d'un fichier ou d'un r\u00e9pertoire peut modifier les droits. Le super utilisateur peut \u00e9galement le faire et il peut m\u00eame changer le propri\u00e9taire. Chaque utilisateur appartient \u00e0 un ou plusieurs groupes . Ces groupes permettent de rassembler les utilisateurs qui ont les m\u00eame droits. 4.2 Droits des r\u00e9pertoires et fichiers \u2693\ufe0e Chaque fichier et chaque r\u00e9pertoire poss\u00e8de une liste de droits : c\u2019est une liste qui indique qui a le droit de lire le fichier ( read ), de le modifier ( write ) et de l\u2019 ex\u00e9cuter ( execute ) ; on y a acc\u00e8s \u00e0 l\u2019aide de la commande ls -l . 4.3 G\u00e9rer les droits \u2693\ufe0e Un utilisateur a le droit de faire un chmod (change mode ) sur un fichier ou un r\u00e9pertoire afin de modifier les droits : s'il est root ; ou s'il est le propri\u00e9taire du fichier ou du r\u00e9pertoire en question. Les options pass\u00e9es \u00e0 la commande chmod sont indiqu\u00e9es comme ceci : chmod options modes fichiers Pour un fichier : chmod [u g o a] [+ - =] [r w x] nom_du_fichier Pour le contenu d'un r\u00e9pertoire (de fa\u00e7on r\u00e9cursive) : chmod -R [u g o a] [+ - =] [r w x] nom_du_r\u00e9pertoire Les lett res u g o a designe les types de propri\u00e9taires** concern\u00e9s: u propri\u00e9taire (user) g groupe (group) o les autres (others) a tous (all) Les lettres + - = d\u00e9signent les changements d'\u00e9tat : + et - pour ajouter ou retirer un type de droit aux droits courants, et l'op\u00e9rateur = pour les \u00e9craser. Les lettres r w x d\u00e9signent les permissions : read, write, execute . Exemple d'utilisation avec le syst\u00e8me de fichier utilis\u00e9 dans les exemples pr\u00e9c\u00e9dents : Sophie propri\u00e9taire d'un fichier jeu.py situ\u00e9 dans le r\u00e9pertoire NSI . Elle a les droits de lecture, d'\u00e9criture et d'execution. Les utilisateurs ,appartenant au m\u00eame groupe que Sophie, ont les droits de lecture mais ceux de d'\u00e9criture et d'execution. Les autres utilisateurs n'ont aucun droits. On peut visualiser \u00e7a avec la commande ls -l . sophie@ma_machine:NSI$ ls -l total 28 -rwxr----- 1 sophie sophie 2690 15 sept. 10 :39 jeu.py Elle souhaite ajouter les droits d'execution aux personnes faisant partie de son groupe sans leur donner la possibilit\u00e9 de modifier (d'\u00e9crire) dans le fichier et uniquement les droits de lecture aux autres. sophie@ma_machine:NSI$ chmod g+x,o+r jeu.py sophie@ma_machine:NSI$ ls -l total 28 -rwxr-xr-- 1 sophie sophie 2690 15 sept. 10 :39 jeu.py La virgule permet de faire plusieurs modifications dans la m\u00eame commande 4.4 Notation octale \u2693\ufe0e Pour modifier toutes les permission d'une seule commande, on utilise la notation octale (On reviendra sur cette partie un peu plus tard dans l'ann\u00e9e).","title":"CH3 : Syst\u00e8mes d'exploitation"},{"location":"Architecture/OS/cours/#ch3-systemes-dexploitation","text":"Programme officiel","title":"CH3 : Syst\u00e8mes d'exploitation"},{"location":"Architecture/OS/cours/#1-quest-ce-quun-systeme-dexploitation","text":"Un syst\u00e8me d\u2019exploitation ( OS pour \"op\u00e9rating system\" ) est un logiciel, ou ensemble de programmes, qui sert d\u2019interface entre les programmes ex\u00e9cut\u00e9s par l\u2019utilisateur et les ressources mat\u00e9rielles d\u2019un ordinateur. Il est \u00e0 la fois : une machine virtuelle qui pr\u00e9sente une interface simplifi\u00e9e d\u2019acc\u00e8s aux ressources (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d\u2019entr\u00e9e/sortie, r\u00e9seau \u2026) pour les autres programmes et pour l\u2019utilisateur un chef d\u2019orchestre et un administrateur : c\u2019est le premier programme ex\u00e9cut\u00e9 au d\u00e9marrage de l\u2019ordinateur il g\u00e8re l\u2019acc\u00e8s concurrent aux ressources par les diff\u00e9rents programmes (ordonnancement de l\u2019utilisation du processeur par les programmes en cours d\u2019ex\u00e9cution ou processus, s\u00e9curisation de la m\u00e9moire) ou utilisateurs (droits d\u2019acc\u00e8s du syst\u00e8me de fichiers). \u00c0 retenir Le syst\u00e8me d'exploitation est l'ensemble des programmes qui permet aux autres programmes d'interagir avec les ressources mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e / sortie) sur un ordinateur. Il sert donc d'interm\u00e9diaire entre le mat\u00e9riel et le logiciel et assure la coordination, la s\u00e9curit\u00e9 et la stabilit\u00e9 d'un environnement partag\u00e9s par plusieurs programmes et plusieurs utilisateurs. Les deux familles de syst\u00e8mes d'exploitation les plus populaires sont Unix (dont macOS , GNU/Linux , iOS et Android ) et Windows . Windows est principalement utilis\u00e9 sur les PC de bureau, c'est un syst\u00e8me d'exploitation propri\u00e9taire tout comme MacOS. Linux au contraire est un syst\u00e8me d'exploitation libre , il est principalement utilis\u00e9 dans les serveurs, t\u00e9l\u00e9phones portables via Android et les supercalculateurs. Comme nous avons au lyc\u00e9e un syst\u00e8me d'exploitation Windows et que le programme officiel demande de travailler sous Linux, vous pouvez passer les commandes de ce chapitre directement dans le navigateur gr\u00e2ce \u00e0 l'\u00e9mulateur de syst\u00e8me mis au point par Fabrice Bellard accessible \u00e0 l'adresse : https://bellard.org/jslinux/vm.html?url=alpine-x86.cfg&mem=192","title":"1. Qu'est ce qu'un syst\u00e8me d'exploitation ?"},{"location":"Architecture/OS/cours/#2-systeme-de-fichier-de-linux","text":"","title":"2. Syst\u00e8me de fichier de Linux"},{"location":"Architecture/OS/cours/#21-arborescence","text":"Avec Linux , comme dans Windows, les donn\u00e9es sont stock\u00e9es dans des fichiers ( file :gb), eux-m\u00eames contenus dans des dossiers appell\u00e9s r\u00e9pertoires ( directory ). Contrairement \u00e0 Windows, sous Linux, la notion de \"disque\" n'existe pas. L'organisation des r\u00e9pertoires et fichiers est appell\u00e9e arborescence . Sous Linux, tout est fichier. Ils sont organis\u00e9s suivant une unique arborescence dont la racine est nomm\u00e9e / . Les r\u00e9pertoires n\u00e9cessaires au fonctionnement du syt\u00e8me d'exploitation sont etc, dev, tmp ... . Les r\u00e9pertoires des utilisateurs sont situ\u00e9s dans le r\u00e9pertoire home","title":"2.1 Arborescence"},{"location":"Architecture/OS/cours/#22-chemin-dun-fichier","text":"Pour localiser un fichier dans cette arborescence on doit d\u00e9finir le chemin d'acc\u00e8s au fichier.","title":"2.2 Chemin d'un fichier"},{"location":"Architecture/OS/cours/#3-interface-utilisateur-dun-systeme-dexploitation","text":"","title":"3. Interface utilisateur d\u2019un syst\u00e8me d\u2019exploitation"},{"location":"Architecture/OS/cours/#31-le-shell","text":"Une interface entre l\u2019utilisateur et le syst\u00e8me d\u2019exploitation s\u2019appelle un shell ou interpr\u00e9teur de commandes . Le r\u00f4le d\u2019un shell est de prendre une entr\u00e9e de l\u2019utilisateur, de la traduire en instructions compr\u00e9hensibles par le syst\u00e8me d\u2019exploitation et de renvoyer la r\u00e9ponse du syst\u00e8me \u00e0 l\u2019utilisateur. Il existe deux grandes cat\u00e9gories de shell : les interfaces textuelles comme bash , le plus commun sur les syst\u00e8mes de la famille UNIX. les interfaces graphiques qu\u2019on retrouve dans les syst\u00e8mes d\u2019exploitation grand public tels que Windows","title":"3.1 Le shell"},{"location":"Architecture/OS/cours/#32-invite-de-commande-et-commandes","text":"On appelle Invite de commande le message qui \u00ab invite \u00bb \u00e0 entrer une commande dans la console/terminal. Exemple : toto@pc12_lycee:~$ toto@pc_lycee d\u00e9signe le nom de l' utilisateur toto sur la machine nomm\u00e9e pc12_lycee . Le signe ~ signifie que l'on se trouve dans le r\u00e9pertoire personnel de l'utilisateur toto . Le symbole dollar $ final signifie que l\u2019utilisateur toto n\u2019est pas l\u2019administrateur de la machine . Lorsqu\u2019on utilise la machine en tant qu\u2019 administrateur , appel\u00e9 root sous UniX, le symbole terminal est # . La syntaxe d'une ligne commande est : nom de la commande suivi \u00e9ventuellement d' -options et d' arguments . Exemple : toto@pc12_lycee:~$ rm -r ./Documents/Dossier_secret La commande est rm . On a une option -r et un argument ./Documents/Dossier_secret . Cela signifie que l'on veut supprimer le r\u00e9pertoire Dossier_secret et tout ce qu'il contient.","title":"3.2 Invite de commande et commandes"},{"location":"Architecture/OS/cours/#33-commandes-de-base-linux","text":"On prendra pour exemple l'arborescence de fichier ci-dessous pour illustrer nos exemples. On est l'utilisateur sophie .","title":"3.3 Commandes de base Linux"},{"location":"Architecture/OS/cours/#4-droits-et-permissions","text":"","title":"4. Droits et permissions"},{"location":"Architecture/OS/cours/#41-utilisateurs-et-groupes-sous-linux","text":"Un syst\u00e8me Linux peut \u00eatre utilis\u00e9 par plusieurs utilisateurs. Un utilisateur est identifi\u00e9 sur une machine par un identifiant ( user id ) et poss\u00e8de un espace de travail personnel avec un r\u00e9pertoire courant. Tous les utilisateurs n'ont pas forc\u00e9ment les m\u00eames droits d'acc\u00e8s et les m\u00eames permissions d'acc\u00e8s aux fichiers et r\u00e9pertoires de la machine. Les droits et permissions sont g\u00e9r\u00e9s par le syst\u00e8me d'exploitation. L' administrateur ou Le super utilisateur (super user ) appell\u00e9 root a acc\u00e8s \u00e0 tous les fichiers et r\u00e9pertoires du syst\u00e8me. Il a tous les droits. La commande sudo (Super-User DO) permet d'ex\u00e9cuter une commande en mode root dans un Terminal. Pour que la commande puisse \u00eatre pass\u00e9e, il faut alors taper le mot de passe administrateur. Le propri\u00e9taire d'un fichier est l'utilisateur qui l'a cr\u00e9\u00e9. Le propri\u00e9taire d'un fichier ou d'un r\u00e9pertoire peut modifier les droits. Le super utilisateur peut \u00e9galement le faire et il peut m\u00eame changer le propri\u00e9taire. Chaque utilisateur appartient \u00e0 un ou plusieurs groupes . Ces groupes permettent de rassembler les utilisateurs qui ont les m\u00eame droits.","title":"4.1 Utilisateurs et groupes sous Linux"},{"location":"Architecture/OS/cours/#42-droits-des-repertoires-et-fichiers","text":"Chaque fichier et chaque r\u00e9pertoire poss\u00e8de une liste de droits : c\u2019est une liste qui indique qui a le droit de lire le fichier ( read ), de le modifier ( write ) et de l\u2019 ex\u00e9cuter ( execute ) ; on y a acc\u00e8s \u00e0 l\u2019aide de la commande ls -l .","title":"4.2 Droits des r\u00e9pertoires et fichiers"},{"location":"Architecture/OS/cours/#43-gerer-les-droits","text":"Un utilisateur a le droit de faire un chmod (change mode ) sur un fichier ou un r\u00e9pertoire afin de modifier les droits : s'il est root ; ou s'il est le propri\u00e9taire du fichier ou du r\u00e9pertoire en question. Les options pass\u00e9es \u00e0 la commande chmod sont indiqu\u00e9es comme ceci : chmod options modes fichiers Pour un fichier : chmod [u g o a] [+ - =] [r w x] nom_du_fichier Pour le contenu d'un r\u00e9pertoire (de fa\u00e7on r\u00e9cursive) : chmod -R [u g o a] [+ - =] [r w x] nom_du_r\u00e9pertoire Les lett res u g o a designe les types de propri\u00e9taires** concern\u00e9s: u propri\u00e9taire (user) g groupe (group) o les autres (others) a tous (all) Les lettres + - = d\u00e9signent les changements d'\u00e9tat : + et - pour ajouter ou retirer un type de droit aux droits courants, et l'op\u00e9rateur = pour les \u00e9craser. Les lettres r w x d\u00e9signent les permissions : read, write, execute . Exemple d'utilisation avec le syst\u00e8me de fichier utilis\u00e9 dans les exemples pr\u00e9c\u00e9dents : Sophie propri\u00e9taire d'un fichier jeu.py situ\u00e9 dans le r\u00e9pertoire NSI . Elle a les droits de lecture, d'\u00e9criture et d'execution. Les utilisateurs ,appartenant au m\u00eame groupe que Sophie, ont les droits de lecture mais ceux de d'\u00e9criture et d'execution. Les autres utilisateurs n'ont aucun droits. On peut visualiser \u00e7a avec la commande ls -l . sophie@ma_machine:NSI$ ls -l total 28 -rwxr----- 1 sophie sophie 2690 15 sept. 10 :39 jeu.py Elle souhaite ajouter les droits d'execution aux personnes faisant partie de son groupe sans leur donner la possibilit\u00e9 de modifier (d'\u00e9crire) dans le fichier et uniquement les droits de lecture aux autres. sophie@ma_machine:NSI$ chmod g+x,o+r jeu.py sophie@ma_machine:NSI$ ls -l total 28 -rwxr-xr-- 1 sophie sophie 2690 15 sept. 10 :39 jeu.py La virgule permet de faire plusieurs modifications dans la m\u00eame commande","title":"4.3 G\u00e9rer les droits"},{"location":"Architecture/OS/cours/#44-notation-octale","text":"Pour modifier toutes les permission d'une seule commande, on utilise la notation octale (On reviendra sur cette partie un peu plus tard dans l'ann\u00e9e).","title":"4.4 Notation octale"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/","text":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine \u2693\ufe0e Programme officiel 1. Les constituants d'une machine \u2693\ufe0e 1.1 D\u00e9monter un ordinateur \u2693\ufe0e 1.2 Constituants et p\u00e9riph\u00e9riques d'un ordinateur \u2693\ufe0e Le micro-ordinateur est traditionnellement compos\u00e9 d\u2019une unit\u00e9 centrale (unit\u00e9 de traitement de l\u2019information), essentiellement un microprocesseur , ainsi que d\u2019 interfaces d\u2019entr\u00e9e (clavier, souris, etc.) et d\u2019 interfaces de sortie (\u00e9cran, imprimante, etc\u2026). Les \u00e9l\u00e9ments pr\u00e9sents sur l'image ci-dessus sont : L\u2019 \u00e9cran : affiche les informations (texte, image, vid\u00e9o, \u2026) La carte m\u00e8re : regroupe les principaux circuits de l\u2019ordinateur Le microprocesseur : ex\u00e9cute les instructions des programmes Les connecteurs pour p\u00e9riph\u00e9riques (disques durs, \u2026) La m\u00e9moire vive (RAM) : stocke momentan\u00e9ment les donn\u00e9es et les programmes Les cartes d\u2019extension : ajoutent des fonctionnalit\u00e9s \u00e0 l\u2019ordinateur (ports, TV, vid\u00e9o, \u2026) L\u2019 alimentation : fournit aux divers composants une \u00e9nergie \u00e9lectrique r\u00e9gul\u00e9e Le(s) lecteur(s)/graveurs(s) optique(s) : CD, DVD, \u2026 Le(s) disque(s) dur(s) : stocke de fa\u00e7on durable les donn\u00e9es et les programmes Le clavier : permet la saisie de caract\u00e8res, \u2026 La souris : permet le pointage d\u2019\u00e9l\u00e9ments sur l\u2019\u00e9cran 2. Le mod\u00e8le d'architecture de Von Neumann \u2693\ufe0e 2.1 Un peu d'histoire \u2693\ufe0e Vid\u00e9o du cours Lumni 2.2 L'architecture de Von Neumann \u2693\ufe0e On \u00e9tudiera en fin d'ann\u00e9e le fonctionnement de cette architecture. Mais pour l'instant on va retenir que les \u00e9l\u00e9ments essentiels d'un ordinateur sont : l\u2019 unit\u00e9 arithm\u00e9tique et logique ( UAL) ou unit\u00e9 de traitement : elle effectue tous les calculs que peut r\u00e9aliser le microprocesseur. l\u2019 unit\u00e9 de contr\u00f4le : elle effectue le \u00ab s\u00e9quen\u00e7age des op\u00e9rations \u00bb en envoyant les ordres \u00e0 l\u2019UAL la m\u00e9moire : elle contient \u00e0 la fois les donn\u00e9es et les programmes. les dispositifs d\u2019entr\u00e9es-sorties : ils permettent de communiquer avec l\u2019ext\u00e9rieur. 2.3 C'est quoi le microprocesseur (CPU) ? \u2693\ufe0e Il est constitu\u00e9 de 3 parties : L\u2019 unit\u00e9 arithm\u00e9tique et logique L\u2019 unit\u00e9 de commande Les registres , qui permettent de m\u00e9moriser de l\u2019information temporairement. 2.4 La m\u00e9moire \u2693\ufe0e La m\u00e9moire permet de stocker des donn\u00e9es et des programmes, elle se divise entre : m\u00e9moire volatile (programmes et donn\u00e9es en cours de fonctionnement, effac\u00e9s lorsque l\u2019alimentation est coup\u00e9e) m\u00e9moire permanente (programmes et donn\u00e9es de base de la machine) Diff\u00e9rents types de m\u00e9moire sont utilis\u00e9s dans un ordinateur : 2.5 Les bus \u2693\ufe0e Le syst\u00e8me permettant la circulation des donn\u00e9es entre les parties de l\u2019ordinateur est appel\u00e9 bus . Il existe 3 grands types de bus : Le bus d\u2019adresses permet de faire circuler des adresses. Le bus de donn\u00e9es permet de faire circuler des donn\u00e9es. Le bus de contr\u00f4le permet de sp\u00e9cifier le type d\u2019action.","title":"Constituants d'une machine"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#ch1-constituants-et-peripheriques-dune-machine","text":"Programme officiel","title":"CH1 : Constituants et p\u00e9riph\u00e9riques d'une machine"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#1-les-constituants-dune-machine","text":"","title":"1. Les constituants d'une machine"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#11-demonter-un-ordinateur","text":"","title":"1.1 D\u00e9monter un ordinateur"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#12-constituants-et-peripheriques-dun-ordinateur","text":"Le micro-ordinateur est traditionnellement compos\u00e9 d\u2019une unit\u00e9 centrale (unit\u00e9 de traitement de l\u2019information), essentiellement un microprocesseur , ainsi que d\u2019 interfaces d\u2019entr\u00e9e (clavier, souris, etc.) et d\u2019 interfaces de sortie (\u00e9cran, imprimante, etc\u2026). Les \u00e9l\u00e9ments pr\u00e9sents sur l'image ci-dessus sont : L\u2019 \u00e9cran : affiche les informations (texte, image, vid\u00e9o, \u2026) La carte m\u00e8re : regroupe les principaux circuits de l\u2019ordinateur Le microprocesseur : ex\u00e9cute les instructions des programmes Les connecteurs pour p\u00e9riph\u00e9riques (disques durs, \u2026) La m\u00e9moire vive (RAM) : stocke momentan\u00e9ment les donn\u00e9es et les programmes Les cartes d\u2019extension : ajoutent des fonctionnalit\u00e9s \u00e0 l\u2019ordinateur (ports, TV, vid\u00e9o, \u2026) L\u2019 alimentation : fournit aux divers composants une \u00e9nergie \u00e9lectrique r\u00e9gul\u00e9e Le(s) lecteur(s)/graveurs(s) optique(s) : CD, DVD, \u2026 Le(s) disque(s) dur(s) : stocke de fa\u00e7on durable les donn\u00e9es et les programmes Le clavier : permet la saisie de caract\u00e8res, \u2026 La souris : permet le pointage d\u2019\u00e9l\u00e9ments sur l\u2019\u00e9cran","title":"1.2 Constituants et p\u00e9riph\u00e9riques d'un ordinateur"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#2-le-modele-darchitecture-de-von-neumann","text":"","title":"2. Le mod\u00e8le d'architecture de Von Neumann"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#21-un-peu-dhistoire","text":"Vid\u00e9o du cours Lumni","title":"2.1 Un peu d'histoire"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#22-larchitecture-de-von-neumann","text":"On \u00e9tudiera en fin d'ann\u00e9e le fonctionnement de cette architecture. Mais pour l'instant on va retenir que les \u00e9l\u00e9ments essentiels d'un ordinateur sont : l\u2019 unit\u00e9 arithm\u00e9tique et logique ( UAL) ou unit\u00e9 de traitement : elle effectue tous les calculs que peut r\u00e9aliser le microprocesseur. l\u2019 unit\u00e9 de contr\u00f4le : elle effectue le \u00ab s\u00e9quen\u00e7age des op\u00e9rations \u00bb en envoyant les ordres \u00e0 l\u2019UAL la m\u00e9moire : elle contient \u00e0 la fois les donn\u00e9es et les programmes. les dispositifs d\u2019entr\u00e9es-sorties : ils permettent de communiquer avec l\u2019ext\u00e9rieur.","title":"2.2 L'architecture de Von Neumann"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#23-cest-quoi-le-microprocesseur-cpu","text":"Il est constitu\u00e9 de 3 parties : L\u2019 unit\u00e9 arithm\u00e9tique et logique L\u2019 unit\u00e9 de commande Les registres , qui permettent de m\u00e9moriser de l\u2019information temporairement.","title":"2.3 C'est quoi le microprocesseur (CPU) ?"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#24-la-memoire","text":"La m\u00e9moire permet de stocker des donn\u00e9es et des programmes, elle se divise entre : m\u00e9moire volatile (programmes et donn\u00e9es en cours de fonctionnement, effac\u00e9s lorsque l\u2019alimentation est coup\u00e9e) m\u00e9moire permanente (programmes et donn\u00e9es de base de la machine) Diff\u00e9rents types de m\u00e9moire sont utilis\u00e9s dans un ordinateur :","title":"2.4 La m\u00e9moire"},{"location":"Architecture/Von%20Neumann%20partie%201/cours/#25-les-bus","text":"Le syst\u00e8me permettant la circulation des donn\u00e9es entre les parties de l\u2019ordinateur est appel\u00e9 bus . Il existe 3 grands types de bus : Le bus d\u2019adresses permet de faire circuler des adresses. Le bus de donn\u00e9es permet de faire circuler des donn\u00e9es. Le bus de contr\u00f4le permet de sp\u00e9cifier le type d\u2019action.","title":"2.5 Les bus"},{"location":"Architecture/Von%20Neumann%20partie%202/cours/","text":"","title":"Cours"},{"location":"Programmation/sommaire/","text":"CH4 : Constructions \u00e9l\u00e9mentaires","title":"Sommaire"},{"location":"Programmation/constructions_elementaires/cours/","text":"CH4 : Constructions \u00e9l\u00e9mentaires \u2693\ufe0e Programme officiel Programmer un ordinateur, c'est quoi ? Programmer, c'est cr\u00e9er des programmes (suite d'instructions donn\u00e9es \u00e0 l'ordinateur) ! Un ordinateur sans programme ne sait rien faire. Il existe diff\u00e9rents langages qui permettent de programmer un ordinateur, mais le seul directement utilisable par le processeur est le langage machine (suite de 1 et de 0). Aujourd'hui (presque) plus personne ne programme en langage machine (trop compliqu\u00e9). Les informaticiens utilisent des instructions (mots souvent en anglais) en lieu et place de la suite de 0 et de 1. Ces instructions, une fois \u00e9crites par le programmeur, sont \"traduites\" en langage machine. Un programme sp\u00e9cialis\u00e9 assure cette traduction. Ce syst\u00e8me de traduction s'appellera interpr\u00e9teur ou bien compilateur , suivant la m\u00e9thode utilis\u00e9e pour effectuer la traduction. Il existe 2 grandes familles de langages de programmation : Les langages de bas niveau sont tr\u00e8s complexes \u00e0 utiliser, car tr\u00e8s \u00e9loign\u00e9s du langage naturel, on dit que ce sont des langages \u00ab proches de la machine \u00bb, en contrepartie ils permettent de faire des programmes tr\u00e8s rapides \u00e0 l'ex\u00e9cution. L' assembleur est le langage de bas niveau. Certains \"morceaux\" de programmes sont \u00e9crits en assembleur encore aujourd'hui. Les langages de haut niveau sont eux plus \"faciles\" \u00e0 utiliser, car plus proches du langage naturel (exemple : si a=3 alors b=c). Exemples de langages de haut niveau : C , C++ , Java , Python ... En NSI, notre langage de pr\u00e9dilection sera Python. 1. S\u00e9quence, Variables, Affectation \u2693\ufe0e 1.1 S\u00e9quence d'intructions \u2693\ufe0e Un programme est une suite d' instructions \u00e9crite dans un langage. En Python, les instructions (lignes du programme) sont \u00e9valu\u00e9es et ex\u00e9cut\u00e9es de haut en bas , \u00e0 l'exception des lignes de commentaires qui commencent # . Exemple : Le programme ci-dessous n'affiche que Bonjour en sortie car la deuxi\u00e8me ligne est comment\u00e9e. 1 2 print ( \"Bonjour\" ) # print(\"aux \u00e9l\u00e8ves de premi\u00e8re NSI.\") 1.2 Variables \u2693\ufe0e C'est une information (une donn\u00e9e) temporaire que l'on stocke dans une case de la RAM. On dit qu'elle est \"variable\", car c'est une valeur qui peut changer pendant le d\u00e9roulement du programme. \u00c0 savoir Une variable est constitu\u00e9e de 2 choses : une valeur pr\u00e9sente en m\u00e9moire (un nombre entier, un nombre \u00e0 virgule, un bool\u00e9en, une chaine de caract\u00e8res, ...); un nom . Une variable est l'association d'un nom et d'une valeur. Exemple : i = 12 Gr\u00e2ce \u00e0 cette ligne, nous avons d\u00e9fini une variable qui porte le nom i . Ce nom i est associ\u00e9 \u00e0 la valeur 12 . Important Le signe = n'a pas la m\u00eame signification qu'en math\u00e9matique. C'est le signe d' affectation . Si on \u00e9crit i = i + 1 , cela signifie que l'on ajoute 1 \u00e0 la valeur de i . Le \"nom\" i pointe maintenant vers la \"valeur\" 13 . Nommage des variables Les r\u00e8gles \u00e0 respecter : le nom de la variable peut contenir les caract\u00e8res suivants : des lettres non accentu\u00e9es (attention, minuscule et majuscule sont des caract\u00e8res diff\u00e9rents) des chiffres (mais pas comme premier caract\u00e8re) le tiret du bas _ (underscore, tiret du 8) le nom de la variable ne doit pas commencer par un chiffre le nom de la variable ne doit pas contenir d'espace le nom de la variable ne doit pas \u00eatre un mot-cl\u00e9 du langage. Et surtout des noms explicites ! Pas bien : if d == 1 : cep = cep + vm Bien : if date == 1 : compte_epargne = compte_epargne + versement_mensuel On utilisera la convention snake_case pour les noms \u00e0 rallonge. 1.3 Typage des variables \u2693\ufe0e Pour diff\u00e9rencier la nature de ce que peut contenir une variable, on parle de type de variable . En voici quelques uns, que nous d\u00e9couvrirons au fil de l'ann\u00e9e : Types de base Voici les types Python les plus fr\u00e9quemment utilis\u00e9s cette ann\u00e9e: Type Python Traduction Exemple int entier 42 float flottant (d\u00e9cimal) 3.1416 str cha\u00eene de caract\u00e8res (string) \"NSI\" bool bool\u00e9en (True ou False) True tuple p-uplet (255, 127, 0) list liste [0, 1, 2, 3, 4, 5] dict dictionnaire {'Homer':43, 'Marge':41, 'Bart':12, 'Lisa':10, 'Maggie':4} function fonction print Comment conna\u00eetre le type d'une variable ? Il suffit dans la console d'utiliser la fonction type . >>> a = 1 >>> type ( a ) < class ' int '> 2. Instructions conditionnelles \u2693\ufe0e 2.1 if \u2693\ufe0e La structure conditionnelle if permet ex\u00e9cuter une (ou plusieurs) instruction(s) SI une condition est vraie (et seulement dans ce cas l\u00e0). age = int ( input ( \"T'as quel \u00e2ge ? \" )) if age < 18 : print ( \"Tu es mineur\" ) Important Remarquer que dans ce cas, il n'y aura aucun affichage si l'age est sup\u00e9rieur (ou \u00e9gal) \u00e0 18. pr\u00e9sence obligatoire du : apr\u00e8s la condition et indentation du bloc d'instruction. L'\u00e9valuation de la condition \u2693\ufe0e L'expression qui suit le if est \u00e9valu\u00e9e par Python lors de l'ex\u00e9cution du programme. Cette \u00e9valuation renvoie un bool\u00e9en, True ou False . Les symboles de comparaison (ou d'appartenance) permettant d'\u00e9crire une condition sont : Op\u00e9rateurs de comparaison Op\u00e9rateur Signification == est \u00e9gal \u00e0 != est diff\u00e9rent de < inf\u00e9rieur \u00e0 > sup\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 in appartient \u00e0 not in n'appartient pas \u00e0 Exemples >>> a = 2 >>> a == 3 False >>> a == 2 True >>> a != 1 True >>> a > 2 False >>> a >= 2 True >>> a <= 2 True >>> a <= 5 True >>> 'e' in 'abracadabra' False >>> 'b' in 'abracadabra' True >>> 'A' not in 'abracadabra' True >>> not True False De plus, ces conditions peuvent \u00eatre combin\u00e9es avec (par exemple) les mots-cl\u00e9s and ou or : >>> b = 20 >>> b > 15 and b < 30 True >>> b > 2000 or b < 30 True 2.2 \u00ecf / else \u2693\ufe0e La structure conditionnelle if .. else .. permet de n'ex\u00e9cuter une (ou plusieurs) instruction(s), que SI la condition du if est Vraie , SINON ce sont les (autres) instructions situ\u00e9es apr\u00e8s le else qui sont ex\u00e9cut\u00e9es. age = int ( input ( \"T'as quel \u00e2ge ? \" )) if age < 18 : print ( \"Tu es mineur\" ) else : print ( \"Tu es majeur\" ) Dans tous les cas (quel que soit l'\u00e2ge), une des deux phrase est affich\u00e9e (on ne peut oublier personne). 2.3 if / elif / else \u2693\ufe0e La structure conditionnelle if .. elif .. else .. permet de r\u00e9aliser plusieurs (plus de deux) tests de comparaison. age = int ( input ( \"T'as quel \u00e2ge ? \" )) if age < 18 : print ( \"T'es trop jeune\" ) elif age >= 18 and age < 30 : # else if <=> elif print ( \"T'es jeune, t'es sympa!\" ) else : # dans tous les autres cas (age >= 30) print ( \"T'es trop vieux!\" ) 3. Boucles \u2693\ufe0e 3.1 Boucle born\u00e9e \u2693\ufe0e a. Iterable \u2693\ufe0e Lorsqu'on peut associer un nombre \u00e0 chaque \u00e9l\u00e9ment d'un ensemble, on dit que l'ensemble est d\u00e9nombrable . Les \u00e9l\u00e8ves aux lyc\u00e9e sont un ensemble d\u00e9nombrable. En informatique, lorqu'on peut \u00e9num\u00e9rer les \u00e9l\u00e9ments d'un objet on parle d' iterables . Exemples : NSI (type str ) est it\u00e9rable : il y a 3 caract\u00e8res N , S et I ; [2, 7, 8] (type list ) est it\u00e9rable : il y a 3 \u00e9l\u00e9ments 2 , 7 et 8 ; 5.3 (type float ) n'est pas it\u00e9rable. On ne peut pas le d\u00e9composer. b. Structure de la boucle for \u2693\ufe0e \u00c0 conna\u00eetre La boucle for s'utilise lorsque : on veut parcourir un \u00e0 un les \u00e9l\u00e9ments d'un objet it\u00e9rable (une cha\u00eene de caract\u00e8re, une liste...); on veut r\u00e9p\u00e9ter une action un nombre de fois connu \u00e0 l'avance . On parle de boucle born\u00e9e . La structure g\u00e9n\u00e9rale est : for element in iterable : instruction 1 instruction 2 ... Important le mot in permet de parcourir l'it\u00e9rable; : obligatoire; indentation obligatoire du bloc d'instruction(s). Des exemples : >>> for car in 'NSI' : print ( car ) N S I >>> for i in range ( 4 ): print ( 'NSI' ) NSI NSI NSI >>> for nb in [ 3 , 5 ]: print ( nb * 2 ) 6 10 Remarques Fonction range La fonction range poss\u00e8de trois arguments dont deux sont optionnels : range(n) renvoie un it\u00e9rateur parcourant les entiers cons\u00e9cutifs entre 0 et n exclu ; range(m, n) renvoie un it\u00e9rateur parcourant les entiers cons\u00e9cutifs entre m et n exclu ; range(m, n, p) renvoie un it\u00e9rateur parcourant les entiers cons\u00e9cutifs entre m et n exclu avec un pas de p ; >>> for i in range ( 10 , - 1 , - 2 ): print ( i ) 10 8 6 4 2 0 Boucles imbriqu\u00e9es Le bloc d'intruction(s) d'une boucle peut contenir une autre boucle. >>> for i in range ( 3 ): for j in range ( 2 ): print ( i , j ) 0 , 0 0 , 1 1 , 0 1 , 1 2 , 0 2 , 1 3.2 Boucle non born\u00e9e \u2693\ufe0e \u00c0 la diff\u00e9rence essentielle des boucles for, dont on peut savoir \u00e0 l'avance combien de fois elles vont \u00eatre ex\u00e9cut\u00e9es, les boucles while sont des boucles dont on ne sort que lorsqu'une condition n'est plus satisfaite. Avec donc le risque de rester infiniment bloqu\u00e9 \u00e0 l'int\u00e9rieur ! \u00c0 conna\u00eetre Syntaxe \u00e0 retenir pour la boucle while : while condition : instruction 1 instruction 2 ... L'\u00e9valuation de la condition est test\u00e9e \u00e0 chaque d\u00e9but de boucle : True : on continue; False : C'est termin\u00e9. Important pr\u00e9sence obligatoire du : apr\u00e8s la condition; indentation obligatoire du bloc d'instruction(s); La condition doit \u00eatre un bool\u00e9en donc une expression \u00e9valu\u00e9e \u00e0 True ou \u00e0 False . Exemple : >>> a = 0 >>> while a < 3 : print ( \"Ok\" ) a = a + 1 print ( \"fini\" ) Ok Ok Ok fini Les pi\u00e8ges ne JAMAIS SORTIR de la boucle ne JAMAIS RENTRER dans la boucle >>> a = 4 >>> while a > 3 : print ( \"Ok\" ) a = a + 1 >>> a = 0 >>> while a > 3 : print ( \"Ok\" ) a = a + 1 >>> Remarques Lien entre for et while La boucle born\u00e9e for que nous avons \u00e9tudi\u00e9e est tr\u00e8s pratique. Mais nous pourrions nous en passer : toutes les boucles for peuvent en fait \u00eatre r\u00e9-\u00e9crites en utilisant while . (alors que la r\u00e9ciproque est fausse). Boucle infinie volontaire La boucle infinie a \u00e9t\u00e9 pr\u00e9sent\u00e9e comme un danger qu'il faut \u00e9viter. Pourtant, dans quelques situations, il est d'usage d'enfermer volontairement l'utilisateur dans une boucle infinie (jeux, affichage, ...). Exemple : 1 2 3 4 5 while True : reponse = input ( \"tapez sur la lettre S du clavier pour me sortir de cet enfer : \" ) if reponse == 'S' or reponse == 's' : break print ( \"merci, j'\u00e9tais bloqu\u00e9 dans une boucle infinie\" ) Le d\u00e9but du code : while True est typique des boucles infinies volontaires. Et l'expression break qui comme son nom l'indique permet de casser la boucle et donc d'en sortir. Son emploi est controvers\u00e9 parmi les puristes de la programmation. Nous dirons juste que c'est une instruction bien pratique. 4. Fonctions \u2693\ufe0e Les fonctions permettent de d\u00e9composer un programme complexe en une s\u00e9rie de sous-programmes plus simples. De plus, les fonctions sont r\u00e9utilisables : si nous disposons d'une fonction capable de calculer une racine carr\u00e9e, par exemple, nous pouvons l'utiliser un peu partout dans notre programme sans avoir \u00e0 la r\u00e9\u00e9crire \u00e0 chaque fois. 4.1 D\u00e9finition d'une fonction \u2693\ufe0e La notion de fonction en informatique est comparable \u00e0 la notion de fonction en math\u00e9matiques. \u00c0 retenir Voici la syntaxe employ\u00e9e en Python pour d\u00e9finir une fonction. 1 2 3 4 def nom_de_fonction ( parametre ): instruction ( s ) ... return valeur_renvoyee Important ne pas oublier les : ; Le d\u00e9calage entre la ligne 1 et le reste du code est appell\u00e9 indentation . Ce bloc de code correspond au contenu de la fonction. Pour indenter vous ins\u00e9rer une tabulation Tab . en l'absence du mot return , la fonction renvoie None cad \"rien\"! Bien / Pas bien On veut cr\u00e9er une fonction calculer_surface_carre qui prend en param\u00e8tre un nombre arrete et qui renvoie la surface du carr\u00e9 d'arr\u00eate arrete . Bien Pas bien 1 2 3 def calculer_surface_carre ( arrete ): surface = arrete ** 2 return surface Les appels de fonctions donnent bien le r\u00e9sultat attendu. >>> cote = 2 >>> print ( f \"La surface d'un carr\u00e9 d'arr\u00eate { cote } est de { calculer_surface_carre ( cote ) } .\" ) La surface d 'un carr\u00e9 d' arr\u00eate 2 est de 4. calculer_surface_carre(cote) revient \u00e0 calculer calculer_surface_carre(2) et cette expression est \u00e9valu\u00e9e \u00e0 4 . 1 2 3 def calculer_surface_carre ( arrete ): surface = arrete ** 2 print ( surface ) Dans un premier temps, on a l'impression que la fonction fait le \"job\". >>> calculer_surface_carre ( 2 ) 4 Ben \u00e7a marche ! Sauf que \"y a pas de return \" ! La fonction ne renvoie rien. Elle ne fait que de l'affichage. >>> cote = 2 >>> print ( f \"La surface d'un carr\u00e9 d'arr\u00eate { cote } est de { calculer_surface_carre ( cote ) } .\" ) La surface d 'un carr\u00e9 d' arr\u00eate 2 est de None . C'est bof bof ! 4.2 Port\u00e9e des variables \u2693\ufe0e \u00c0 retenir Les variables d\u00e9finies dans le corps d'une fonction sont appel\u00e9es variables locales . Les variables d\u00e9finies dans le corps du programme (sous-entendu : pas \u00e0 l'int\u00e9rieur d'une fonction) sont appel\u00e9es variables globales . R\u00e8gles d'acc\u00e8s aux variables locales et globales r\u00e8gle 1 : une variable locale (d\u00e9finie au c\u0153ur d'une fonction) est inaccessible hors de cette fonction. r\u00e8gle 2 : une variable globale (d\u00e9finie \u00e0 l'ext\u00e9rieur d'une fonction) est accessible en lecture \u00e0 l'int\u00e9rieur d'une fonction. r\u00e8gle 3 : une variable globale (d\u00e9finie \u00e0 l'ext\u00e9rieur d'une fonction) ne peut pas \u00eatre modifi\u00e9e \u00e0 l'int\u00e9rieur d'une fonction. Exercice \u00c9nonc\u00e9 Correction code A Correction code B Correction code C On consid\u00e8re les 3 codes ci-dessous. Pour chacun, dire sans l'ex\u00e9cuter s'il est valide ou non. S'il ne l'est pas, identifier la r\u00e8gle (parmi celles \u00e9nonc\u00e9es ci-dessus) qui est bafou\u00e9e. code A 1 2 3 4 5 points = 0 def verdict ( reponse ): if reponse > 10 : points += 3 verdict ( 12 ) code B 1 2 3 4 def bouge ( x , decalage ): x += decalage bouge ( 100 , 5 ) print ( x ) code C 1 2 3 4 5 6 7 8 9 def test_bac ( moyenne ): if moyenne >= 10 : print ( \"admis !\" ) def coup_de_pouce ( note ): return note + bonus bonus = 0.6 ma_moyenne = 9.5 ma_moyenne = coup_de_pouce ( ma_moyenne ) test_bac ( ma_moyenne ) Ce code n'est pas valide, car il contrevient \u00e0 la r\u00e8gle 3. ligne 4 : la modification de la variable globale points est interdite. Ce code n'est pas valide, car il contrevient \u00e0 la r\u00e8gle 1. ligne 5 : l'acc\u00e8s \u00e0 la variable locale x est interdit. Ce code est valide. ligne 6 : l'acc\u00e8s \u00e0 la variable globale bonus est autoris\u00e9, selon la r\u00e8gle 2. Sources Pages tir\u00e9es de : https://glassus.github.io/premiere_nsi/T1_Demarrer_en_Python/sommaire/ https://dav74.github.io/site_nsi_prem/c1c/ https://www.lyceum.fr/1g/nsi/7-langages-et-programmation/1-les-ingredients-dun-algorithme https://eskool.gitlab.io/1nsi/python/ http://frederic-junier.org/NSI/premiere/chapitre1/","title":"Constructions \u00e9l\u00e9mentaires"},{"location":"Programmation/constructions_elementaires/cours/#ch4-constructions-elementaires","text":"Programme officiel Programmer un ordinateur, c'est quoi ? Programmer, c'est cr\u00e9er des programmes (suite d'instructions donn\u00e9es \u00e0 l'ordinateur) ! Un ordinateur sans programme ne sait rien faire. Il existe diff\u00e9rents langages qui permettent de programmer un ordinateur, mais le seul directement utilisable par le processeur est le langage machine (suite de 1 et de 0). Aujourd'hui (presque) plus personne ne programme en langage machine (trop compliqu\u00e9). Les informaticiens utilisent des instructions (mots souvent en anglais) en lieu et place de la suite de 0 et de 1. Ces instructions, une fois \u00e9crites par le programmeur, sont \"traduites\" en langage machine. Un programme sp\u00e9cialis\u00e9 assure cette traduction. Ce syst\u00e8me de traduction s'appellera interpr\u00e9teur ou bien compilateur , suivant la m\u00e9thode utilis\u00e9e pour effectuer la traduction. Il existe 2 grandes familles de langages de programmation : Les langages de bas niveau sont tr\u00e8s complexes \u00e0 utiliser, car tr\u00e8s \u00e9loign\u00e9s du langage naturel, on dit que ce sont des langages \u00ab proches de la machine \u00bb, en contrepartie ils permettent de faire des programmes tr\u00e8s rapides \u00e0 l'ex\u00e9cution. L' assembleur est le langage de bas niveau. Certains \"morceaux\" de programmes sont \u00e9crits en assembleur encore aujourd'hui. Les langages de haut niveau sont eux plus \"faciles\" \u00e0 utiliser, car plus proches du langage naturel (exemple : si a=3 alors b=c). Exemples de langages de haut niveau : C , C++ , Java , Python ... En NSI, notre langage de pr\u00e9dilection sera Python.","title":"CH4 : Constructions \u00e9l\u00e9mentaires"},{"location":"Programmation/constructions_elementaires/cours/#1-sequence-variables-affectation","text":"","title":"1. S\u00e9quence, Variables, Affectation"},{"location":"Programmation/constructions_elementaires/cours/#11-sequence-dintructions","text":"Un programme est une suite d' instructions \u00e9crite dans un langage. En Python, les instructions (lignes du programme) sont \u00e9valu\u00e9es et ex\u00e9cut\u00e9es de haut en bas , \u00e0 l'exception des lignes de commentaires qui commencent # . Exemple : Le programme ci-dessous n'affiche que Bonjour en sortie car la deuxi\u00e8me ligne est comment\u00e9e. 1 2 print ( \"Bonjour\" ) # print(\"aux \u00e9l\u00e8ves de premi\u00e8re NSI.\")","title":"1.1 S\u00e9quence d'intructions"},{"location":"Programmation/constructions_elementaires/cours/#12-variables","text":"C'est une information (une donn\u00e9e) temporaire que l'on stocke dans une case de la RAM. On dit qu'elle est \"variable\", car c'est une valeur qui peut changer pendant le d\u00e9roulement du programme. \u00c0 savoir Une variable est constitu\u00e9e de 2 choses : une valeur pr\u00e9sente en m\u00e9moire (un nombre entier, un nombre \u00e0 virgule, un bool\u00e9en, une chaine de caract\u00e8res, ...); un nom . Une variable est l'association d'un nom et d'une valeur. Exemple : i = 12 Gr\u00e2ce \u00e0 cette ligne, nous avons d\u00e9fini une variable qui porte le nom i . Ce nom i est associ\u00e9 \u00e0 la valeur 12 . Important Le signe = n'a pas la m\u00eame signification qu'en math\u00e9matique. C'est le signe d' affectation . Si on \u00e9crit i = i + 1 , cela signifie que l'on ajoute 1 \u00e0 la valeur de i . Le \"nom\" i pointe maintenant vers la \"valeur\" 13 . Nommage des variables Les r\u00e8gles \u00e0 respecter : le nom de la variable peut contenir les caract\u00e8res suivants : des lettres non accentu\u00e9es (attention, minuscule et majuscule sont des caract\u00e8res diff\u00e9rents) des chiffres (mais pas comme premier caract\u00e8re) le tiret du bas _ (underscore, tiret du 8) le nom de la variable ne doit pas commencer par un chiffre le nom de la variable ne doit pas contenir d'espace le nom de la variable ne doit pas \u00eatre un mot-cl\u00e9 du langage. Et surtout des noms explicites ! Pas bien : if d == 1 : cep = cep + vm Bien : if date == 1 : compte_epargne = compte_epargne + versement_mensuel On utilisera la convention snake_case pour les noms \u00e0 rallonge.","title":"1.2 Variables"},{"location":"Programmation/constructions_elementaires/cours/#13-typage-des-variables","text":"Pour diff\u00e9rencier la nature de ce que peut contenir une variable, on parle de type de variable . En voici quelques uns, que nous d\u00e9couvrirons au fil de l'ann\u00e9e : Types de base Voici les types Python les plus fr\u00e9quemment utilis\u00e9s cette ann\u00e9e: Type Python Traduction Exemple int entier 42 float flottant (d\u00e9cimal) 3.1416 str cha\u00eene de caract\u00e8res (string) \"NSI\" bool bool\u00e9en (True ou False) True tuple p-uplet (255, 127, 0) list liste [0, 1, 2, 3, 4, 5] dict dictionnaire {'Homer':43, 'Marge':41, 'Bart':12, 'Lisa':10, 'Maggie':4} function fonction print Comment conna\u00eetre le type d'une variable ? Il suffit dans la console d'utiliser la fonction type . >>> a = 1 >>> type ( a ) < class ' int '>","title":"1.3 Typage des variables"},{"location":"Programmation/constructions_elementaires/cours/#2-instructions-conditionnelles","text":"","title":"2. Instructions conditionnelles"},{"location":"Programmation/constructions_elementaires/cours/#21-if","text":"La structure conditionnelle if permet ex\u00e9cuter une (ou plusieurs) instruction(s) SI une condition est vraie (et seulement dans ce cas l\u00e0). age = int ( input ( \"T'as quel \u00e2ge ? \" )) if age < 18 : print ( \"Tu es mineur\" ) Important Remarquer que dans ce cas, il n'y aura aucun affichage si l'age est sup\u00e9rieur (ou \u00e9gal) \u00e0 18. pr\u00e9sence obligatoire du : apr\u00e8s la condition et indentation du bloc d'instruction.","title":"2.1 if"},{"location":"Programmation/constructions_elementaires/cours/#22-if-else","text":"La structure conditionnelle if .. else .. permet de n'ex\u00e9cuter une (ou plusieurs) instruction(s), que SI la condition du if est Vraie , SINON ce sont les (autres) instructions situ\u00e9es apr\u00e8s le else qui sont ex\u00e9cut\u00e9es. age = int ( input ( \"T'as quel \u00e2ge ? \" )) if age < 18 : print ( \"Tu es mineur\" ) else : print ( \"Tu es majeur\" ) Dans tous les cas (quel que soit l'\u00e2ge), une des deux phrase est affich\u00e9e (on ne peut oublier personne).","title":"2.2 \u00ecf / else"},{"location":"Programmation/constructions_elementaires/cours/#23-if-elif-else","text":"La structure conditionnelle if .. elif .. else .. permet de r\u00e9aliser plusieurs (plus de deux) tests de comparaison. age = int ( input ( \"T'as quel \u00e2ge ? \" )) if age < 18 : print ( \"T'es trop jeune\" ) elif age >= 18 and age < 30 : # else if <=> elif print ( \"T'es jeune, t'es sympa!\" ) else : # dans tous les autres cas (age >= 30) print ( \"T'es trop vieux!\" )","title":"2.3 if / elif / else"},{"location":"Programmation/constructions_elementaires/cours/#3-boucles","text":"","title":"3. Boucles"},{"location":"Programmation/constructions_elementaires/cours/#31-boucle-bornee","text":"","title":"3.1 Boucle born\u00e9e"},{"location":"Programmation/constructions_elementaires/cours/#32-boucle-non-bornee","text":"\u00c0 la diff\u00e9rence essentielle des boucles for, dont on peut savoir \u00e0 l'avance combien de fois elles vont \u00eatre ex\u00e9cut\u00e9es, les boucles while sont des boucles dont on ne sort que lorsqu'une condition n'est plus satisfaite. Avec donc le risque de rester infiniment bloqu\u00e9 \u00e0 l'int\u00e9rieur ! \u00c0 conna\u00eetre Syntaxe \u00e0 retenir pour la boucle while : while condition : instruction 1 instruction 2 ... L'\u00e9valuation de la condition est test\u00e9e \u00e0 chaque d\u00e9but de boucle : True : on continue; False : C'est termin\u00e9. Important pr\u00e9sence obligatoire du : apr\u00e8s la condition; indentation obligatoire du bloc d'instruction(s); La condition doit \u00eatre un bool\u00e9en donc une expression \u00e9valu\u00e9e \u00e0 True ou \u00e0 False . Exemple : >>> a = 0 >>> while a < 3 : print ( \"Ok\" ) a = a + 1 print ( \"fini\" ) Ok Ok Ok fini Les pi\u00e8ges ne JAMAIS SORTIR de la boucle ne JAMAIS RENTRER dans la boucle >>> a = 4 >>> while a > 3 : print ( \"Ok\" ) a = a + 1 >>> a = 0 >>> while a > 3 : print ( \"Ok\" ) a = a + 1 >>> Remarques Lien entre for et while La boucle born\u00e9e for que nous avons \u00e9tudi\u00e9e est tr\u00e8s pratique. Mais nous pourrions nous en passer : toutes les boucles for peuvent en fait \u00eatre r\u00e9-\u00e9crites en utilisant while . (alors que la r\u00e9ciproque est fausse). Boucle infinie volontaire La boucle infinie a \u00e9t\u00e9 pr\u00e9sent\u00e9e comme un danger qu'il faut \u00e9viter. Pourtant, dans quelques situations, il est d'usage d'enfermer volontairement l'utilisateur dans une boucle infinie (jeux, affichage, ...). Exemple : 1 2 3 4 5 while True : reponse = input ( \"tapez sur la lettre S du clavier pour me sortir de cet enfer : \" ) if reponse == 'S' or reponse == 's' : break print ( \"merci, j'\u00e9tais bloqu\u00e9 dans une boucle infinie\" ) Le d\u00e9but du code : while True est typique des boucles infinies volontaires. Et l'expression break qui comme son nom l'indique permet de casser la boucle et donc d'en sortir. Son emploi est controvers\u00e9 parmi les puristes de la programmation. Nous dirons juste que c'est une instruction bien pratique.","title":"3.2 Boucle non born\u00e9e"},{"location":"Programmation/constructions_elementaires/cours/#4-fonctions","text":"Les fonctions permettent de d\u00e9composer un programme complexe en une s\u00e9rie de sous-programmes plus simples. De plus, les fonctions sont r\u00e9utilisables : si nous disposons d'une fonction capable de calculer une racine carr\u00e9e, par exemple, nous pouvons l'utiliser un peu partout dans notre programme sans avoir \u00e0 la r\u00e9\u00e9crire \u00e0 chaque fois.","title":"4. Fonctions"},{"location":"Programmation/constructions_elementaires/cours/#41-definition-dune-fonction","text":"La notion de fonction en informatique est comparable \u00e0 la notion de fonction en math\u00e9matiques. \u00c0 retenir Voici la syntaxe employ\u00e9e en Python pour d\u00e9finir une fonction. 1 2 3 4 def nom_de_fonction ( parametre ): instruction ( s ) ... return valeur_renvoyee Important ne pas oublier les : ; Le d\u00e9calage entre la ligne 1 et le reste du code est appell\u00e9 indentation . Ce bloc de code correspond au contenu de la fonction. Pour indenter vous ins\u00e9rer une tabulation Tab . en l'absence du mot return , la fonction renvoie None cad \"rien\"! Bien / Pas bien On veut cr\u00e9er une fonction calculer_surface_carre qui prend en param\u00e8tre un nombre arrete et qui renvoie la surface du carr\u00e9 d'arr\u00eate arrete . Bien Pas bien 1 2 3 def calculer_surface_carre ( arrete ): surface = arrete ** 2 return surface Les appels de fonctions donnent bien le r\u00e9sultat attendu. >>> cote = 2 >>> print ( f \"La surface d'un carr\u00e9 d'arr\u00eate { cote } est de { calculer_surface_carre ( cote ) } .\" ) La surface d 'un carr\u00e9 d' arr\u00eate 2 est de 4. calculer_surface_carre(cote) revient \u00e0 calculer calculer_surface_carre(2) et cette expression est \u00e9valu\u00e9e \u00e0 4 . 1 2 3 def calculer_surface_carre ( arrete ): surface = arrete ** 2 print ( surface ) Dans un premier temps, on a l'impression que la fonction fait le \"job\". >>> calculer_surface_carre ( 2 ) 4 Ben \u00e7a marche ! Sauf que \"y a pas de return \" ! La fonction ne renvoie rien. Elle ne fait que de l'affichage. >>> cote = 2 >>> print ( f \"La surface d'un carr\u00e9 d'arr\u00eate { cote } est de { calculer_surface_carre ( cote ) } .\" ) La surface d 'un carr\u00e9 d' arr\u00eate 2 est de None . C'est bof bof !","title":"4.1 D\u00e9finition d'une fonction"},{"location":"Programmation/constructions_elementaires/cours/#42-portee-des-variables","text":"\u00c0 retenir Les variables d\u00e9finies dans le corps d'une fonction sont appel\u00e9es variables locales . Les variables d\u00e9finies dans le corps du programme (sous-entendu : pas \u00e0 l'int\u00e9rieur d'une fonction) sont appel\u00e9es variables globales . R\u00e8gles d'acc\u00e8s aux variables locales et globales r\u00e8gle 1 : une variable locale (d\u00e9finie au c\u0153ur d'une fonction) est inaccessible hors de cette fonction. r\u00e8gle 2 : une variable globale (d\u00e9finie \u00e0 l'ext\u00e9rieur d'une fonction) est accessible en lecture \u00e0 l'int\u00e9rieur d'une fonction. r\u00e8gle 3 : une variable globale (d\u00e9finie \u00e0 l'ext\u00e9rieur d'une fonction) ne peut pas \u00eatre modifi\u00e9e \u00e0 l'int\u00e9rieur d'une fonction. Exercice \u00c9nonc\u00e9 Correction code A Correction code B Correction code C On consid\u00e8re les 3 codes ci-dessous. Pour chacun, dire sans l'ex\u00e9cuter s'il est valide ou non. S'il ne l'est pas, identifier la r\u00e8gle (parmi celles \u00e9nonc\u00e9es ci-dessus) qui est bafou\u00e9e. code A 1 2 3 4 5 points = 0 def verdict ( reponse ): if reponse > 10 : points += 3 verdict ( 12 ) code B 1 2 3 4 def bouge ( x , decalage ): x += decalage bouge ( 100 , 5 ) print ( x ) code C 1 2 3 4 5 6 7 8 9 def test_bac ( moyenne ): if moyenne >= 10 : print ( \"admis !\" ) def coup_de_pouce ( note ): return note + bonus bonus = 0.6 ma_moyenne = 9.5 ma_moyenne = coup_de_pouce ( ma_moyenne ) test_bac ( ma_moyenne ) Ce code n'est pas valide, car il contrevient \u00e0 la r\u00e8gle 3. ligne 4 : la modification de la variable globale points est interdite. Ce code n'est pas valide, car il contrevient \u00e0 la r\u00e8gle 1. ligne 5 : l'acc\u00e8s \u00e0 la variable locale x est interdit. Ce code est valide. ligne 6 : l'acc\u00e8s \u00e0 la variable globale bonus est autoris\u00e9, selon la r\u00e8gle 2. Sources Pages tir\u00e9es de : https://glassus.github.io/premiere_nsi/T1_Demarrer_en_Python/sommaire/ https://dav74.github.io/site_nsi_prem/c1c/ https://www.lyceum.fr/1g/nsi/7-langages-et-programmation/1-les-ingredients-dun-algorithme https://eskool.gitlab.io/1nsi/python/ http://frederic-junier.org/NSI/premiere/chapitre1/","title":"4.2 Port\u00e9e des variables"},{"location":"Types%20bases/sommaire/","text":"CH2 : Op\u00e9rateurs bool\u00e9ens CH6 : \u00c9crire un entier positif dans une base sup\u00e9rieure ou \u00e9gale \u00e0 2","title":"Sommaire"},{"location":"Types%20bases/Bases/cours/","text":"CH5 : \u00c9crire un entier positif dans une base sup\u00e9rieure ou \u00e9gale \u00e0 2 \u2693\ufe0e Programme officiel 1. \u00c9criture des nombres entiers positifs en base 10 \u2693\ufe0e En base \\(10\\) , syst\u00e8me d\u00e9cimal , il y exactement 10 chiffres : \\(0\\) , \\(1\\) , \\(2\\) , \\(3\\) , \\(4\\) , \\(5\\) , \\(6\\) , \\(7\\) , \\(8\\) , \\(9\\) . Consid\u00e9rons un nombre entier, \u00e9crit en base \\(10\\) (en d\u00e9cimal), par exemple \\(2743\\) : On peut transformer l'\u00e9criture de ce nombre de la mani\u00e8re suivante : \\[\\begin{align} 2743 &= 2000 + 700 + 40 + 3 \\\\ &= 2\\times1000 + 7\\times100 + 4\\times10 + 3\\times1 \\\\ &= 2\\times10^3 + 7\\times10^2 + 4\\times10^1 + 3\\times10^0 \\end{align} \\] \u00c0 savoir En base \\(10\\) , Tout nombre entier peut \u00eatre \u00e9crit comme une somme coefficient\u00e9e de puissances de \\(10\\) . Pour d\u00e9terminer cette somme coefficient\u00e9e : Au dessus de chaque chiffre, de droite \u00e0 gauche , on \u00e9crit des puissances croissantes de \\(10\\) (en commen\u00e7ant par \\(10^0\\) ) : \\[10^3\\,\\,10^2\\,\\,10^1\\,\\,10^0\\] \\[ 2 \\,\\,\\,\\,\\,\\,\\,\\, 7 \\,\\,\\,\\,\\,\\,\\,\\, 4 \\,\\,\\,\\,\\,\\,\\,3\\] On multiplie chaque chiffre (= le coefficient) par la puissance de \\(10\\) correspondante : \\[2743 = 2\\times10^3 + 7\\times10^2 + 4\\times10^1 + 3\\times10^0\\] 2. Repr\u00e9sentation en base 2 des entiers positifs \u2693\ufe0e 2.1 Bits et mots machine \u2693\ufe0e Dans un ordinateur, toutes les informations (donn\u00e9es ou programmes) sont repr\u00e9sent\u00e9es gr\u00e2ce \u00e0 des 0 et des 1. \u00c0 conna\u00eetre Un bit (pour BInary digiT) est un \\(0\\) ou bien un \\(1\\) ; Un ensemble de 8 bits est appel\u00e9 un octet ou un byte ; Un mot machine ou words est un ensemble de 2, 4 ou 8 octets . Exemple : Une machine de 32 bits est un ordinateur manipulant des mots de 4 octets ( \\(4\\times8 = 32\\) bits). C'est ce principe de regroupement en paquets de bits, ou mots machine, qui permet de donner un sens \u00e0 tout le paquet de bits et ainsi pouvoir repr\u00e9senter et manipuler des donn\u00e9es autres que des \\(0\\) et des \\(1\\) : des nombres entiers (positifs ou n\u00e9gatifs), des (approximations de) nombres r\u00e9els, des caract\u00e8res alphanum\u00e9riques et des textes, des images, des sons, des vid\u00e9os ... 2.2 Convertion binaire -> d\u00e9cimal \u2693\ufe0e Savoir faire Pour convertir un nombre entier, donn\u00e9 en base \\(2\\) (binaire), vers le d\u00e9cimal, on proc\u00e8de ainsi: Au dessus de chaque chiffre, de droite \u00e0 gauche , on \u00e9crit des puissances croissantes de \\(2\\) : \\[2^4\\,\\,\\,\\,\\,2^3\\,\\,\\,\\,\\,2^2\\,\\,\\,\\,\\,2^1\\,\\,\\,\\,\\,2^0\\] \\[1 \\,\\,\\,\\,\\,\\,\\,\\, 1 \\,\\,\\,\\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\,\\,\\,1\\] On multiplie chaque chiffre par la puissance de \\(2\\) correspondante : \\[\\begin{align} 11001 &= 1\\times2^4 + 1\\times2^3 + 0\\times2^2 + 0\\times2^1 + 1\\times2^0 \\\\ &= 1\\times16 + 1\\times8 + 0\\times4 + 0\\times2 + 1\\times1 \\\\ &= 16 + 8 + 1 \\\\ &= 25 \\end{align} \\] Remarques : Notation Pour lever l'ambig\u00fcit\u00e9 entre les notations D\u00e9cimale et Binaire (par ex. pour des nombres d\u00e9cimaux tels que 110), on note les nombres en \u00e9criture binaire en utilisant la notation : 110 2 . Et en python, la notation sera 0b110 . conversion binaire vers d\u00e9cimal en Python >>> int ( '0b11011' , 2 ) 27 2.3 Convertion d\u00e9cimal -> binaire \u2693\ufe0e Savoir faire Pour convertir un nombre d\u00e9cimal (en base \\(10\\) ) en nombre binaire (en base \\(2\\) ) on proc\u00e8de ainsi : r\u00e9aliser la division euclidienne du nombre d\u00e9cimal (en base \\(10\\) ) par 2, jusqu'\u00e0 ce que le quotient soit \u00e9gal \u00e0 0 . lire alors la suite de tous les Restes mais \u00e0 l'envers (en commen\u00e7ant du bas vers la haut) Dans cet exemple, on peut dire que: 83 10 = 1010011 2 Conversion d\u00e9cimal vers binaire en Python >>> bin ( 1534 ) '0b10111111110' 3. Repr\u00e9sentation hexad\u00e9cimale des entiers positifs \u2693\ufe0e 3.1 Les chiffres de la base hexad\u00e9cimale \u2693\ufe0e L'inconv\u00e9nient essentiel du syst\u00e8me binaire est la longueur de l'\u00e9criture des nombres qu'il g\u00e9n\u00e8re. Pour cette raison, le syst\u00e8me hexad\u00e9cimal , ou syst\u00e8me de base 16 est tr\u00e8s souvent employ\u00e9. Pour \u00e9crire en base 2, il faut 2 chiffres diff\u00e9rents : le 0 et le 1. Pour \u00e9crire en base 10, il faut 10 chiffres diff\u00e9rents: 0,1,2,3,4,5,6,7,8,9. Pour \u00e9crire en base 16, il faut donc 16 chiffres diff\u00e9rents : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F . On a donc la correspondance : A repr\u00e9sente 10 B repr\u00e9sente 11 C repr\u00e9sente 12 D repr\u00e9sente 13 E repr\u00e9sente 14 F repr\u00e9sente 15 3.2 Convertion hexad\u00e9cimal -> d\u00e9cimal \u2693\ufe0e Savoir faire Pour faire la conversion, on proc\u00e8de comme pour passer du binaire au d\u00e9cimal mais on utilise les puissances de 16 . \\(4A5E = 4\\times16^3+10\\times16^2+5\\times16^1+14\\times16^0=19038_{10}\\) Hexad\u00e9cimal \\(4\\) \\(A\\) \\(5\\) \\(E\\) Exposant \\(3\\) \\(2\\) \\(1\\) \\(0\\) Puissance de \\(16\\) \\(16^3\\) \\(16^2\\) \\(16^1\\) \\(16^0\\) Remarques : Notation On note les nombres en \u00e9criture hexad\u00e9cimale : 4A5E 16 . Et en python, la notation sera 0x4a5e . Conversion hexad\u00e9cimal vers d\u00e9cimal en Python >>> int ( '0x4a5e' , 16 ) 19038 3.3 Convertion d\u00e9cimal -> hexad\u00e9cimal \u2693\ufe0e Savoir faire Pour convertir un nombre d\u00e9cimal en nombre hexad\u00e9cimal on proc\u00e8de de la m\u00eame fa\u00e7con que pour le binaire : r\u00e9aliser la division euclidienne du nombre d\u00e9cimal par 16, jusqu'\u00e0 ce que le quotient soit \u00e9gal \u00e0 0 . lire alors la suite de tous les Restes mais \u00e0 l'envers (en commen\u00e7ant du bas vers la haut) Dans cet exemple, on peut dire que: 2526 10 = 9DE 16 Conversion d\u00e9cimal vers hexad\u00e9cimal en Python >>> hex ( 1534 ) '0x5fe' 3.4 \u00c9criture des octets \u2693\ufe0e Un octet (mot de 8 bits) peut repr\u00e9sente des valeurs comprises entre 0 et 255 10 . 0 pour 0000 0000 en binaire ou 00 en hexad\u00e9cimal. 255 pour 1111 1111 en binaire ou FF en hexad\u00e9cimal. M\u00e9thode pour passer du binaire \u00e0 l'hexad\u00e9cimal Tableau de correspondance des chiffres en hexad\u00e9cimal hexa bin (sur 4 bits) dec 0 0000 0 1 0001 1 2 0010 2 3 0011 3 - ---- - 9 1001 9 A 1010 10 B 1011 11 C 1100 12 D 1101 13 E 1110 14 F 1111 15 Pour convertir un octet repr\u00e9sent\u00e9 en binaire en hexad\u00e9cimal, il faut s\u00e9parer l'\u00e9criture de l'octet en deux \"paquets\" de 4 bits et faire la correspondance avec les chiffres du tableau. Exemple : 0100 1010 repr\u00e9sente l'octet 4A en hexad\u00e9cimal. Faire le contraire pour passer de la repr\u00e9sentation en hexad\u00e9cimal \u00e0 la repr\u00e9sentation bianire. Exemple : E5 repr\u00e9sente l'octet 1110 0101 en binaire. 4. G\u00e9n\u00e9ralisation pour une base b quelconque \u2693\ufe0e On g\u00e9n\u00e9ralise le Syst\u00e8me de Num\u00e9ration D\u00e9cimale positionnelle, en un Syst\u00e8me de Num\u00e9ration positionnel de base b . Il faut d\u00e9j\u00e0 commencer par choisir des notations pour un ensemble de * b chiffres : Si \\(b\\le 10\\) , alors les chiffres sont un sous-ensemble de {0,1,2,3,4,5,6,7,8,9}; Si \\(b\\gt 10\\) , alors les chiffres simples ne suffisent plus, il en faut de nouveaux. On choisit les chiffres dans l'ensemble {0,1,2,3,4,5,6,7,8,9,A,B,C,..,X,Y,Z}. Notation d'un nombre x en base b x b d\u00e9signent le nombre x \u00e9crit en base b. 4.1 \u00c9criture de Nombres en Base b \u2693\ufe0e Pour lire, on proc\u00e8de comme pour les autres bases mais on utilise les puissances de b . Exemple d'un nombre entier positif \u00e9crit en base 4 : \\(312 = 3\\times4^2+1\\times4^1+2\\times4^0=54_{10}\\) | Base 4 | $3$ | $1$ | $2$ | | :-: | :-: | :-: | :-: | | Exposant | $2$ | $1$ | $0$ | | Puissance de $4$ | $4^2$ | $4^1$ | $4^0$ | z\u00e9ro en base b Le chiffre z\u00e9ro s'\u00e9crit 0 dans toutes les bases 4.2 Conversion de bases \u2693\ufe0e Conversion de base \\(a\\) \\(\\Leftrightarrow\\) base \\(b\\) Pour convertir un nombre \\(x_a\\) d'une base \\(a\\) vers une base \\(b\\) (et/ou r\u00e9ciproquement), il suffit (par exemple) de passer par le d\u00e9cimal (base \\(10\\) ): Base \\(a \\Leftrightarrow\\) Base \\(10 \\Leftrightarrow\\) Base \\(b\\) Conversion Base \\(8\\) \\(\\rightarrow\\) Base \\(2\\) Soit \\(x = 1261_8\\) un nombre en base \\(8\\) . Comment \u00e9crire \\(x\\) en base \\(2\\) ? Corr Conversion de \\(x\\) en Base \\(10\\) \\(\\begin{align} x &= (1\\times 8^3+2\\times 8^2+6\\times 8^1+1\\times 8^0)_{10} \\\\ &= (512 + 128 + 48 + 1)_{10} \\\\ &= 689_{10} \\end{align}\\) Conversion Base \\(10\\) \\(\\rightarrow\\) Base \\(2\\) : On r\u00e9alise une succession de divisions euclidiennes par \\(2\\) , on conservant \u00e0 chaque fois les restes : \\(689\\) \\(344\\) \\(\\rightarrow\\) reste \\(1\\) \\(172\\) \\(\\rightarrow\\) reste \\(0\\) \\(86\\) \\(\\rightarrow\\) reste \\(0\\) \\(43\\) \\(\\rightarrow\\) reste \\(0\\) \\(21\\) \\(\\rightarrow\\) reste \\(1\\) \\(10\\) \\(\\rightarrow\\) reste \\(1\\) \\(5\\) \\(\\rightarrow\\) reste \\(0\\) \\(2\\) \\(\\rightarrow\\) reste \\(1\\) \\(1\\) \\(\\rightarrow\\) reste \\(0\\) \\(0\\) \\(\\rightarrow\\) reste \\(1\\) Conclusion : \\(689_{10} = 1010110001_2\\) Conclusion : \\(1261_8 = 1010110001_2\\) Conversion Directe Base \\(a\\) \\(\\Rightarrow\\) Base \\(b\\) On peut aussi convertir directement un nombre \\(x\\) en base \\(a\\) ( \\(x_a\\) ), vers une base \\(b\\) , en : r\u00e9alisant une succession de divisions de \\(x_a\\) par \\(b\\) , jusqu'\u00e0 ce que le quotient soit \u00e9gal \u00e0 \\(0\\) en conservant les restes \\(r\\) pour chaque division ( \\(0\\le r \\lt b\\) ) Le nombre \\(x_b\\) ( \\(x\\) en base \\(b\\) ) est alors obtenu en lisant les restes \u00e0 l'envers (du dernier vers le premier)","title":"Bases"},{"location":"Types%20bases/Bases/cours/#ch5-ecrire-un-entier-positif-dans-une-base-superieure-ou-egale-a-2","text":"Programme officiel","title":"CH5 : \u00c9crire un entier positif dans une base sup\u00e9rieure ou \u00e9gale \u00e0 2"},{"location":"Types%20bases/Bases/cours/#1-ecriture-des-nombres-entiers-positifs-en-base-10","text":"En base \\(10\\) , syst\u00e8me d\u00e9cimal , il y exactement 10 chiffres : \\(0\\) , \\(1\\) , \\(2\\) , \\(3\\) , \\(4\\) , \\(5\\) , \\(6\\) , \\(7\\) , \\(8\\) , \\(9\\) . Consid\u00e9rons un nombre entier, \u00e9crit en base \\(10\\) (en d\u00e9cimal), par exemple \\(2743\\) : On peut transformer l'\u00e9criture de ce nombre de la mani\u00e8re suivante : \\[\\begin{align} 2743 &= 2000 + 700 + 40 + 3 \\\\ &= 2\\times1000 + 7\\times100 + 4\\times10 + 3\\times1 \\\\ &= 2\\times10^3 + 7\\times10^2 + 4\\times10^1 + 3\\times10^0 \\end{align} \\] \u00c0 savoir En base \\(10\\) , Tout nombre entier peut \u00eatre \u00e9crit comme une somme coefficient\u00e9e de puissances de \\(10\\) . Pour d\u00e9terminer cette somme coefficient\u00e9e : Au dessus de chaque chiffre, de droite \u00e0 gauche , on \u00e9crit des puissances croissantes de \\(10\\) (en commen\u00e7ant par \\(10^0\\) ) : \\[10^3\\,\\,10^2\\,\\,10^1\\,\\,10^0\\] \\[ 2 \\,\\,\\,\\,\\,\\,\\,\\, 7 \\,\\,\\,\\,\\,\\,\\,\\, 4 \\,\\,\\,\\,\\,\\,\\,3\\] On multiplie chaque chiffre (= le coefficient) par la puissance de \\(10\\) correspondante : \\[2743 = 2\\times10^3 + 7\\times10^2 + 4\\times10^1 + 3\\times10^0\\]","title":"1. \u00c9criture des nombres entiers positifs en base 10"},{"location":"Types%20bases/Bases/cours/#2-representation-en-base-2-des-entiers-positifs","text":"","title":"2. Repr\u00e9sentation en base 2 des entiers positifs"},{"location":"Types%20bases/Bases/cours/#21-bits-et-mots-machine","text":"Dans un ordinateur, toutes les informations (donn\u00e9es ou programmes) sont repr\u00e9sent\u00e9es gr\u00e2ce \u00e0 des 0 et des 1. \u00c0 conna\u00eetre Un bit (pour BInary digiT) est un \\(0\\) ou bien un \\(1\\) ; Un ensemble de 8 bits est appel\u00e9 un octet ou un byte ; Un mot machine ou words est un ensemble de 2, 4 ou 8 octets . Exemple : Une machine de 32 bits est un ordinateur manipulant des mots de 4 octets ( \\(4\\times8 = 32\\) bits). C'est ce principe de regroupement en paquets de bits, ou mots machine, qui permet de donner un sens \u00e0 tout le paquet de bits et ainsi pouvoir repr\u00e9senter et manipuler des donn\u00e9es autres que des \\(0\\) et des \\(1\\) : des nombres entiers (positifs ou n\u00e9gatifs), des (approximations de) nombres r\u00e9els, des caract\u00e8res alphanum\u00e9riques et des textes, des images, des sons, des vid\u00e9os ...","title":"2.1 Bits et mots machine"},{"location":"Types%20bases/Bases/cours/#22-convertion-binaire-decimal","text":"Savoir faire Pour convertir un nombre entier, donn\u00e9 en base \\(2\\) (binaire), vers le d\u00e9cimal, on proc\u00e8de ainsi: Au dessus de chaque chiffre, de droite \u00e0 gauche , on \u00e9crit des puissances croissantes de \\(2\\) : \\[2^4\\,\\,\\,\\,\\,2^3\\,\\,\\,\\,\\,2^2\\,\\,\\,\\,\\,2^1\\,\\,\\,\\,\\,2^0\\] \\[1 \\,\\,\\,\\,\\,\\,\\,\\, 1 \\,\\,\\,\\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\,\\,\\,1\\] On multiplie chaque chiffre par la puissance de \\(2\\) correspondante : \\[\\begin{align} 11001 &= 1\\times2^4 + 1\\times2^3 + 0\\times2^2 + 0\\times2^1 + 1\\times2^0 \\\\ &= 1\\times16 + 1\\times8 + 0\\times4 + 0\\times2 + 1\\times1 \\\\ &= 16 + 8 + 1 \\\\ &= 25 \\end{align} \\] Remarques : Notation Pour lever l'ambig\u00fcit\u00e9 entre les notations D\u00e9cimale et Binaire (par ex. pour des nombres d\u00e9cimaux tels que 110), on note les nombres en \u00e9criture binaire en utilisant la notation : 110 2 . Et en python, la notation sera 0b110 . conversion binaire vers d\u00e9cimal en Python >>> int ( '0b11011' , 2 ) 27","title":"2.2 Convertion binaire -&gt; d\u00e9cimal"},{"location":"Types%20bases/Bases/cours/#23-convertion-decimal-binaire","text":"Savoir faire Pour convertir un nombre d\u00e9cimal (en base \\(10\\) ) en nombre binaire (en base \\(2\\) ) on proc\u00e8de ainsi : r\u00e9aliser la division euclidienne du nombre d\u00e9cimal (en base \\(10\\) ) par 2, jusqu'\u00e0 ce que le quotient soit \u00e9gal \u00e0 0 . lire alors la suite de tous les Restes mais \u00e0 l'envers (en commen\u00e7ant du bas vers la haut) Dans cet exemple, on peut dire que: 83 10 = 1010011 2 Conversion d\u00e9cimal vers binaire en Python >>> bin ( 1534 ) '0b10111111110'","title":"2.3 Convertion d\u00e9cimal -&gt; binaire"},{"location":"Types%20bases/Bases/cours/#3-representation-hexadecimale-des-entiers-positifs","text":"","title":"3. Repr\u00e9sentation hexad\u00e9cimale des entiers positifs"},{"location":"Types%20bases/Bases/cours/#31-les-chiffres-de-la-base-hexadecimale","text":"L'inconv\u00e9nient essentiel du syst\u00e8me binaire est la longueur de l'\u00e9criture des nombres qu'il g\u00e9n\u00e8re. Pour cette raison, le syst\u00e8me hexad\u00e9cimal , ou syst\u00e8me de base 16 est tr\u00e8s souvent employ\u00e9. Pour \u00e9crire en base 2, il faut 2 chiffres diff\u00e9rents : le 0 et le 1. Pour \u00e9crire en base 10, il faut 10 chiffres diff\u00e9rents: 0,1,2,3,4,5,6,7,8,9. Pour \u00e9crire en base 16, il faut donc 16 chiffres diff\u00e9rents : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F . On a donc la correspondance : A repr\u00e9sente 10 B repr\u00e9sente 11 C repr\u00e9sente 12 D repr\u00e9sente 13 E repr\u00e9sente 14 F repr\u00e9sente 15","title":"3.1 Les chiffres de la base hexad\u00e9cimale"},{"location":"Types%20bases/Bases/cours/#32-convertion-hexadecimal-decimal","text":"Savoir faire Pour faire la conversion, on proc\u00e8de comme pour passer du binaire au d\u00e9cimal mais on utilise les puissances de 16 . \\(4A5E = 4\\times16^3+10\\times16^2+5\\times16^1+14\\times16^0=19038_{10}\\) Hexad\u00e9cimal \\(4\\) \\(A\\) \\(5\\) \\(E\\) Exposant \\(3\\) \\(2\\) \\(1\\) \\(0\\) Puissance de \\(16\\) \\(16^3\\) \\(16^2\\) \\(16^1\\) \\(16^0\\) Remarques : Notation On note les nombres en \u00e9criture hexad\u00e9cimale : 4A5E 16 . Et en python, la notation sera 0x4a5e . Conversion hexad\u00e9cimal vers d\u00e9cimal en Python >>> int ( '0x4a5e' , 16 ) 19038","title":"3.2 Convertion hexad\u00e9cimal -&gt; d\u00e9cimal"},{"location":"Types%20bases/Bases/cours/#33-convertion-decimal-hexadecimal","text":"Savoir faire Pour convertir un nombre d\u00e9cimal en nombre hexad\u00e9cimal on proc\u00e8de de la m\u00eame fa\u00e7con que pour le binaire : r\u00e9aliser la division euclidienne du nombre d\u00e9cimal par 16, jusqu'\u00e0 ce que le quotient soit \u00e9gal \u00e0 0 . lire alors la suite de tous les Restes mais \u00e0 l'envers (en commen\u00e7ant du bas vers la haut) Dans cet exemple, on peut dire que: 2526 10 = 9DE 16 Conversion d\u00e9cimal vers hexad\u00e9cimal en Python >>> hex ( 1534 ) '0x5fe'","title":"3.3 Convertion d\u00e9cimal -&gt; hexad\u00e9cimal"},{"location":"Types%20bases/Bases/cours/#34-ecriture-des-octets","text":"Un octet (mot de 8 bits) peut repr\u00e9sente des valeurs comprises entre 0 et 255 10 . 0 pour 0000 0000 en binaire ou 00 en hexad\u00e9cimal. 255 pour 1111 1111 en binaire ou FF en hexad\u00e9cimal. M\u00e9thode pour passer du binaire \u00e0 l'hexad\u00e9cimal Tableau de correspondance des chiffres en hexad\u00e9cimal hexa bin (sur 4 bits) dec 0 0000 0 1 0001 1 2 0010 2 3 0011 3 - ---- - 9 1001 9 A 1010 10 B 1011 11 C 1100 12 D 1101 13 E 1110 14 F 1111 15 Pour convertir un octet repr\u00e9sent\u00e9 en binaire en hexad\u00e9cimal, il faut s\u00e9parer l'\u00e9criture de l'octet en deux \"paquets\" de 4 bits et faire la correspondance avec les chiffres du tableau. Exemple : 0100 1010 repr\u00e9sente l'octet 4A en hexad\u00e9cimal. Faire le contraire pour passer de la repr\u00e9sentation en hexad\u00e9cimal \u00e0 la repr\u00e9sentation bianire. Exemple : E5 repr\u00e9sente l'octet 1110 0101 en binaire.","title":"3.4 \u00c9criture des octets"},{"location":"Types%20bases/Bases/cours/#4-generalisation-pour-une-base-b-quelconque","text":"On g\u00e9n\u00e9ralise le Syst\u00e8me de Num\u00e9ration D\u00e9cimale positionnelle, en un Syst\u00e8me de Num\u00e9ration positionnel de base b . Il faut d\u00e9j\u00e0 commencer par choisir des notations pour un ensemble de * b chiffres : Si \\(b\\le 10\\) , alors les chiffres sont un sous-ensemble de {0,1,2,3,4,5,6,7,8,9}; Si \\(b\\gt 10\\) , alors les chiffres simples ne suffisent plus, il en faut de nouveaux. On choisit les chiffres dans l'ensemble {0,1,2,3,4,5,6,7,8,9,A,B,C,..,X,Y,Z}. Notation d'un nombre x en base b x b d\u00e9signent le nombre x \u00e9crit en base b.","title":"4. G\u00e9n\u00e9ralisation pour une base b quelconque"},{"location":"Types%20bases/Bases/cours/#41-ecriture-de-nombres-en-base-b","text":"Pour lire, on proc\u00e8de comme pour les autres bases mais on utilise les puissances de b . Exemple d'un nombre entier positif \u00e9crit en base 4 : \\(312 = 3\\times4^2+1\\times4^1+2\\times4^0=54_{10}\\) | Base 4 | $3$ | $1$ | $2$ | | :-: | :-: | :-: | :-: | | Exposant | $2$ | $1$ | $0$ | | Puissance de $4$ | $4^2$ | $4^1$ | $4^0$ | z\u00e9ro en base b Le chiffre z\u00e9ro s'\u00e9crit 0 dans toutes les bases","title":"4.1 \u00c9criture de Nombres en Base b"},{"location":"Types%20bases/Bases/cours/#42-conversion-de-bases","text":"Conversion de base \\(a\\) \\(\\Leftrightarrow\\) base \\(b\\) Pour convertir un nombre \\(x_a\\) d'une base \\(a\\) vers une base \\(b\\) (et/ou r\u00e9ciproquement), il suffit (par exemple) de passer par le d\u00e9cimal (base \\(10\\) ): Base \\(a \\Leftrightarrow\\) Base \\(10 \\Leftrightarrow\\) Base \\(b\\) Conversion Base \\(8\\) \\(\\rightarrow\\) Base \\(2\\) Soit \\(x = 1261_8\\) un nombre en base \\(8\\) . Comment \u00e9crire \\(x\\) en base \\(2\\) ? Corr Conversion de \\(x\\) en Base \\(10\\) \\(\\begin{align} x &= (1\\times 8^3+2\\times 8^2+6\\times 8^1+1\\times 8^0)_{10} \\\\ &= (512 + 128 + 48 + 1)_{10} \\\\ &= 689_{10} \\end{align}\\) Conversion Base \\(10\\) \\(\\rightarrow\\) Base \\(2\\) : On r\u00e9alise une succession de divisions euclidiennes par \\(2\\) , on conservant \u00e0 chaque fois les restes : \\(689\\) \\(344\\) \\(\\rightarrow\\) reste \\(1\\) \\(172\\) \\(\\rightarrow\\) reste \\(0\\) \\(86\\) \\(\\rightarrow\\) reste \\(0\\) \\(43\\) \\(\\rightarrow\\) reste \\(0\\) \\(21\\) \\(\\rightarrow\\) reste \\(1\\) \\(10\\) \\(\\rightarrow\\) reste \\(1\\) \\(5\\) \\(\\rightarrow\\) reste \\(0\\) \\(2\\) \\(\\rightarrow\\) reste \\(1\\) \\(1\\) \\(\\rightarrow\\) reste \\(0\\) \\(0\\) \\(\\rightarrow\\) reste \\(1\\) Conclusion : \\(689_{10} = 1010110001_2\\) Conclusion : \\(1261_8 = 1010110001_2\\) Conversion Directe Base \\(a\\) \\(\\Rightarrow\\) Base \\(b\\) On peut aussi convertir directement un nombre \\(x\\) en base \\(a\\) ( \\(x_a\\) ), vers une base \\(b\\) , en : r\u00e9alisant une succession de divisions de \\(x_a\\) par \\(b\\) , jusqu'\u00e0 ce que le quotient soit \u00e9gal \u00e0 \\(0\\) en conservant les restes \\(r\\) pour chaque division ( \\(0\\le r \\lt b\\) ) Le nombre \\(x_b\\) ( \\(x\\) en base \\(b\\) ) est alors obtenu en lisant les restes \u00e0 l'envers (du dernier vers le premier)","title":"4.2 Conversion de bases"},{"location":"Types%20bases/Booleens/cours/","text":"CH2 : Les op\u00e9rateurs bool\u00e9ens \u2693\ufe0e Programme officiel 1. Le calcul bool\u00e9en \u2693\ufe0e 1.1 Un peu d'histoire \u2693\ufe0e En 1847, le britannique George BOOLE inventa un formalisme permettant d'\u00e9crire des raisonnements logiques : l' alg\u00e8bre de Boole . La notion m\u00eame d'informatique n'existait pas \u00e0 l'\u00e9poque, m\u00eame si les calculs \u00e9taient d\u00e9j\u00e0 automatis\u00e9s (penser \u00e0 la Pascaline de 1642). Bien plus tard, en 1938, les travaux de l'am\u00e9ricain Claude SHANNON prouva que des circuits \u00e9lectriques peuvent r\u00e9soudre tous les probl\u00e8mes que l'alg\u00e8bre de Boole peut elle-m\u00eame r\u00e9soudre. Pendant la deuxi\u00e8me guerre mondiale, les travaux d' Alan TURING puis de John VON NEUMANN poseront d\u00e9finitivement les bases de l'informatique moderne. 1.2 Variable bool\u00e9enne \u2693\ufe0e \u00c0 savoir Une variable bool\u00e9enne est une variable qui ne peut prendre que deux valeurs possibles : Vrai ( True ) ou 1 Faux ( False ) ou 0 Une variable bool\u00e9enne en Python est du type bool . >>> a = False >>> print ( type ( a )) < class ' bool '> Remarque : Ouvert/Ferm\u00e9 (interrupteur), Allum\u00e9/\u00c9teint (lampe), 5V/0V (tension), Blanc/Noir (pixels d'une image noir et blanc) ... sont \u00e9galement des variables bool\u00e9ennes. 1.3 Op\u00e9rateurs bool\u00e9ens \u2693\ufe0e Un op\u00e9rateur bool\u00e9en est un op\u00e9rateur math\u00e9matique qui manipule des variables bool\u00e9ennes. Une expression bool\u00e9enne est une expression dont le r\u00e9sultat est un bool\u00e9en. Un op\u00e9rande est un \u00e9l\u00e9ment sur lequel on applique un op\u00e9rateur bool\u00e9en. a. L'op\u00e9rateur not \u2693\ufe0e \u00c0 conna\u00eetre L'op\u00e9rateur not (\"non\" ) est l'op\u00e9rateur de n\u00e9gation : si on note a la variable d'entr\u00e9e, not a ou \\(\\mathrm{\\overline{a}}\\) renvoie la n\u00e9gation de a. Table de v\u00e9rit\u00e9 de not a not a 0 1 1 0 En python >>> a = True >>> print ( not a ) False >>> b = not a >>> print ( not b ) True b. L'op\u00e9rateur and \u2693\ufe0e \u00c0 conna\u00eetre L'op\u00e9rateur and (\"et\" ) est un op\u00e9rateur de conjonction . Si a et b sont deux variables bool\u00e9ennes, a and b renvoie Vrai si a et b sont Vrai toutes les deux, et Faux sinon. La table de v\u00e9rit\u00e9 de and a b a and b 0 0 0 0 1 0 1 0 0 1 1 1 En python >>> a = True >>> b = True >>> c = False >>> print ( a and b ) True >>> print ( c and b ) False c. L'op\u00e9rateur or \u2693\ufe0e \u00c0 conna\u00eetre L'op\u00e9rateur or (\"ou\" ) est un op\u00e9rateur de disjonction . Si a et b sont deux variables bool\u00e9ennes, a or b renvoie Vrai quand au moins un des deux op\u00e9randes a ou b sont Vrai, et Faux sinon. La table de v\u00e9rit\u00e9 de or a b a or b 0 0 0 0 1 1 1 0 1 1 1 1 En python >>> a = True >>> b = True >>> c = False >>> d = False >>> print ( a or b ) True >>> print ( c or b ) True >>> print ( d or c ) False d. L'op\u00e9rateur xor \u2693\ufe0e \u00c0 savoir L'op\u00e9rateur xor (\"ou exclusif\" ) est un op\u00e9rateur de disjonction exclusive . Si a et b sont deux variables bool\u00e9ennes, a xor b renvoie Vrai un seul des deux op\u00e9randes a ou b sont Vrai, et Faux sinon. La table de v\u00e9rit\u00e9 de xor a b a xor b 0 0 0 0 1 1 1 0 1 1 1 0 1.4 \u00c9valuation d'une expression bool\u00e9enne \u2693\ufe0e \u00c0 conna\u00eetre Il faut faire comme en math\u00e9matique. On doit tenir compte de la priorit\u00e9 des op\u00e9rations et des parenth\u00e8ses. Le not est prioritaire devant and qui lui-m\u00eame est prioritaire devant or ou xor . Expression comportant uniquement des valeurs bool\u00e9ennes \u2693\ufe0e Exemple : A = True and True or (not False and False) On commence par la parenth\u00e8se ( not False devient True puis True and False devient False : A = True and True or (True and False) = True and True or False Puis and est prioritaire devant or (donc True and True devient True ): A = True or False On a enfin A = True Expression comportant des variables bool\u00e9ennes \u2693\ufe0e Pour \u00e9valuer l'expression, on peut \u00e9tablir une table de v\u00e9rit\u00e9 . Il faut faire la table de v\u00e9rit\u00e9 de chaque partie de l'expression en tenant compte des r\u00e8gles pr\u00e9c\u00e9dentes. Exemple de l'expression a or not b : a b not b a or not b 0 0 1 1 0 1 0 0 1 0 1 1 1 1 0 1 1.5 Les expressions bool\u00e9ennes et python \u2693\ufe0e Les op\u00e9rateurs bool\u00e9ens \u2693\ufe0e Remarque 1 : \u2693\ufe0e Les op\u00e9rateurs bool\u00e9ens sont not , and et or . Ne pas confondre avec les op\u00e9rateurs de comparaison qui renvoient une valeur bool\u00e9enne. >>> 4 // 2 == 3 False >>> ( 7 > 3 ) and ( 9 != 8 ) and not False True Dans ces deux exemples == , > , != sont des op\u00e9rateurs de comparaison qui renvoient un bool\u00e9en. Remarque 2 : \u2693\ufe0e Python pratique l' \u00e9valuation paresseuse (short-circuit evaluation ). L'\u00e9valuation paresseuse le fait que l'interpr\u00e9teur Python s'arr\u00eate d\u00e8s que sa d\u00e9cision est prise. Exemple : >>> ( 20 // 2 == 8 ) and ( 20 // 4 == 5 ) False Comme le premier bool\u00e9en vaut False et que la conjonction and est appel\u00e9e, il n'est pas n\u00e9cessaire d'\u00e9valuer le deuxi\u00e8me bool\u00e9en. Essayez de lancer dans le terminal ci-dessous : False and print(\"Salut\") et comparez le \u00e0 True and print(\"Salut\") . Comparez ensuite avec l'op\u00e9rateur or . >>> 2. De l'expression bool\u00e9enne au composant \u00e9lectronique \u2693\ufe0e 2.1 Un peu d'histoire \u2693\ufe0e Les circuits d\u2019un ordinateur manipulent uniquement des 0 ou des 1 repr\u00e9sent\u00e9s en interne par des tensions hautes ou basses . Les premiers ordinateurs construits dans la p\u00e9riode 1945-1950 sont bas\u00e9s sur une technologie de tube \u00e0 vide ou tube \u00e9lectrique . En 1947, aux laboratoires Bell, Shockley, Bardeen et Brattain inventent le transistor , un petit composant \u00e9lectronique qui se comporte comme un interrupteur. Les transistors, plus petits et dissipant moins de chaleur, vont supplanter les tubes \u00e9lectriques. En 1954 le germanium est remplac\u00e9 par le silicium, en 1955 apparaissent les premiers ordinateurs enti\u00e8rement transistoris\u00e9s. En 1960 le transistor \u00e0 effet de champ permet l\u2019int\u00e9gration de dizaines composants dans un centim\u00e8tre carr\u00e9. Les transistors sont ensuite directement grav\u00e9s dans une plaque de silicium constituant un cicrcuit int\u00e9gr\u00e9 . En 1965, Gordon Moore futur directeur d\u2019Intel \u00e9nonce la loi empirique suivante : il y aura doublement de la densit\u00e9 d\u2019int\u00e9gration des transistors tous les deux ans. Cette loi s\u2019est v\u00e9rifi\u00e9e jusqu\u2019\u00e0 pr\u00e9sent avec une finesse de gravure d\u2019environ 5 nanom\u00e8tres en 2020. Le graphique ci-dessous repr\u00e9sente l\u2019\u00e9volution du nombre de transistors par circuit int\u00e9gr\u00e9. 2.2 Les portes logiques \u2693\ufe0e Dans un ordinateur, les op\u00e9rations de calcul sont effectu\u00e9es en binaire, \u00e0 l'aide de portes logiques . En associant des transistors, on r\u00e9alise ces portes logiques. Une porte logique est un circuit \u00e9lectronique repr\u00e9sentant une fonction logique. Voici ci-dessous la repr\u00e9sentation de quelques portes (repr\u00e9sentation am\u00e9ricaine et internationnale) 2.3 Circuit combinatoire \u2693\ufe0e Un circuit logique combinatoire permet de r\u00e9aliser une ou plusieurs fonctions bool\u00e9ennes : ses sorties ne d\u00e9pendent que de l'\u00e9tat actuel de ses entr\u00e9es. Les portes logiques NOT, NOR, NAND, AND, OR et XOR sont des circuits combinatoires. Exemple Que fait ce circuit ? Aide : Simuler en ligne Solution D\u00e9terminer la fonction logique r\u00e9aliser par ce circuit. R\u00e9aliser des circuits logiques et les tester ici On a r\u00e9alis\u00e9 une porte xor . Vous pouvez v\u00e9rifier que (a and not b) or (not a and b) = a xor b Il existe d'autres circuits, dits s\u00e9quentiels , dont les sorties se calculent non seulement \u00e0 partir de leurs valeurs d\u2019entr\u00e9e actuelles mais aussi \u00e0 partir de leurs \u00e9tats pr\u00e9c\u00e9dents : le facteur temps intervient. Ils utilisent des circuits de m\u00e9moire pour m\u00e9moriser leurs \u00e9tats ant\u00e9rieurs.","title":"Op\u00e9rateurs bool\u00e9ens"},{"location":"Types%20bases/Booleens/cours/#ch2-les-operateurs-booleens","text":"Programme officiel","title":"CH2 : Les op\u00e9rateurs bool\u00e9ens"},{"location":"Types%20bases/Booleens/cours/#1-le-calcul-booleen","text":"","title":"1. Le calcul bool\u00e9en"},{"location":"Types%20bases/Booleens/cours/#11-un-peu-dhistoire","text":"En 1847, le britannique George BOOLE inventa un formalisme permettant d'\u00e9crire des raisonnements logiques : l' alg\u00e8bre de Boole . La notion m\u00eame d'informatique n'existait pas \u00e0 l'\u00e9poque, m\u00eame si les calculs \u00e9taient d\u00e9j\u00e0 automatis\u00e9s (penser \u00e0 la Pascaline de 1642). Bien plus tard, en 1938, les travaux de l'am\u00e9ricain Claude SHANNON prouva que des circuits \u00e9lectriques peuvent r\u00e9soudre tous les probl\u00e8mes que l'alg\u00e8bre de Boole peut elle-m\u00eame r\u00e9soudre. Pendant la deuxi\u00e8me guerre mondiale, les travaux d' Alan TURING puis de John VON NEUMANN poseront d\u00e9finitivement les bases de l'informatique moderne.","title":"1.1 Un peu d'histoire"},{"location":"Types%20bases/Booleens/cours/#12-variable-booleenne","text":"\u00c0 savoir Une variable bool\u00e9enne est une variable qui ne peut prendre que deux valeurs possibles : Vrai ( True ) ou 1 Faux ( False ) ou 0 Une variable bool\u00e9enne en Python est du type bool . >>> a = False >>> print ( type ( a )) < class ' bool '> Remarque : Ouvert/Ferm\u00e9 (interrupteur), Allum\u00e9/\u00c9teint (lampe), 5V/0V (tension), Blanc/Noir (pixels d'une image noir et blanc) ... sont \u00e9galement des variables bool\u00e9ennes.","title":"1.2 Variable bool\u00e9enne"},{"location":"Types%20bases/Booleens/cours/#13-operateurs-booleens","text":"Un op\u00e9rateur bool\u00e9en est un op\u00e9rateur math\u00e9matique qui manipule des variables bool\u00e9ennes. Une expression bool\u00e9enne est une expression dont le r\u00e9sultat est un bool\u00e9en. Un op\u00e9rande est un \u00e9l\u00e9ment sur lequel on applique un op\u00e9rateur bool\u00e9en.","title":"1.3 Op\u00e9rateurs bool\u00e9ens"},{"location":"Types%20bases/Booleens/cours/#14-evaluation-dune-expression-booleenne","text":"\u00c0 conna\u00eetre Il faut faire comme en math\u00e9matique. On doit tenir compte de la priorit\u00e9 des op\u00e9rations et des parenth\u00e8ses. Le not est prioritaire devant and qui lui-m\u00eame est prioritaire devant or ou xor .","title":"1.4 \u00c9valuation d'une expression bool\u00e9enne"},{"location":"Types%20bases/Booleens/cours/#15-les-expressions-booleennes-et-python","text":"","title":"1.5 Les expressions bool\u00e9ennes et python"},{"location":"Types%20bases/Booleens/cours/#2-de-lexpression-booleenne-au-composant-electronique","text":"","title":"2. De l'expression bool\u00e9enne au composant \u00e9lectronique"},{"location":"Types%20bases/Booleens/cours/#21-un-peu-dhistoire","text":"Les circuits d\u2019un ordinateur manipulent uniquement des 0 ou des 1 repr\u00e9sent\u00e9s en interne par des tensions hautes ou basses . Les premiers ordinateurs construits dans la p\u00e9riode 1945-1950 sont bas\u00e9s sur une technologie de tube \u00e0 vide ou tube \u00e9lectrique . En 1947, aux laboratoires Bell, Shockley, Bardeen et Brattain inventent le transistor , un petit composant \u00e9lectronique qui se comporte comme un interrupteur. Les transistors, plus petits et dissipant moins de chaleur, vont supplanter les tubes \u00e9lectriques. En 1954 le germanium est remplac\u00e9 par le silicium, en 1955 apparaissent les premiers ordinateurs enti\u00e8rement transistoris\u00e9s. En 1960 le transistor \u00e0 effet de champ permet l\u2019int\u00e9gration de dizaines composants dans un centim\u00e8tre carr\u00e9. Les transistors sont ensuite directement grav\u00e9s dans une plaque de silicium constituant un cicrcuit int\u00e9gr\u00e9 . En 1965, Gordon Moore futur directeur d\u2019Intel \u00e9nonce la loi empirique suivante : il y aura doublement de la densit\u00e9 d\u2019int\u00e9gration des transistors tous les deux ans. Cette loi s\u2019est v\u00e9rifi\u00e9e jusqu\u2019\u00e0 pr\u00e9sent avec une finesse de gravure d\u2019environ 5 nanom\u00e8tres en 2020. Le graphique ci-dessous repr\u00e9sente l\u2019\u00e9volution du nombre de transistors par circuit int\u00e9gr\u00e9.","title":"2.1 Un peu d'histoire"},{"location":"Types%20bases/Booleens/cours/#22-les-portes-logiques","text":"Dans un ordinateur, les op\u00e9rations de calcul sont effectu\u00e9es en binaire, \u00e0 l'aide de portes logiques . En associant des transistors, on r\u00e9alise ces portes logiques. Une porte logique est un circuit \u00e9lectronique repr\u00e9sentant une fonction logique. Voici ci-dessous la repr\u00e9sentation de quelques portes (repr\u00e9sentation am\u00e9ricaine et internationnale)","title":"2.2 Les portes logiques"},{"location":"Types%20bases/Booleens/cours/#23-circuit-combinatoire","text":"Un circuit logique combinatoire permet de r\u00e9aliser une ou plusieurs fonctions bool\u00e9ennes : ses sorties ne d\u00e9pendent que de l'\u00e9tat actuel de ses entr\u00e9es. Les portes logiques NOT, NOR, NAND, AND, OR et XOR sont des circuits combinatoires. Exemple Que fait ce circuit ? Aide : Simuler en ligne Solution D\u00e9terminer la fonction logique r\u00e9aliser par ce circuit. R\u00e9aliser des circuits logiques et les tester ici On a r\u00e9alis\u00e9 une porte xor . Vous pouvez v\u00e9rifier que (a and not b) or (not a and b) = a xor b Il existe d'autres circuits, dits s\u00e9quentiels , dont les sorties se calculent non seulement \u00e0 partir de leurs valeurs d\u2019entr\u00e9e actuelles mais aussi \u00e0 partir de leurs \u00e9tats pr\u00e9c\u00e9dents : le facteur temps intervient. Ils utilisent des circuits de m\u00e9moire pour m\u00e9moriser leurs \u00e9tats ant\u00e9rieurs.","title":"2.3 Circuit combinatoire"},{"location":"Types%20construits/sommaire/","text":"CH5 : p-uplets CH7 : Tableaux","title":"Sommaire"},{"location":"Types%20construits/p_uplets/cours/","text":"CH5 : p-uplets \u2693\ufe0e Programme officiel 1. Les s\u00e9quences en Python \u2693\ufe0e Il est possible de \"stocker\" plusieurs grandeurs dans une m\u00eame structure, ce type de structure est appel\u00e9 une s\u00e9quence . De fa\u00e7on plus pr\u00e9cise, nous d\u00e9finirons une s\u00e9quence comme un ensemble fini et ordonn\u00e9 d'\u00e9l\u00e9ments indic\u00e9s de 0 \u00e0 n-1 si cette s\u00e9quence comporte n \u00e9l\u00e9ments . On \u00e9tudie plus particuli\u00e8rement 2 types de s\u00e9quences : les tuples et les tableaux (il en existe d'autres que nous n'\u00e9voquerons pas ici). 2. D\u00e9finition des tuples \u2693\ufe0e \u00c0 savoir Les tuples (appel\u00e9s p-uplets dans le programme officiel de NSI) sont une collection d'objets ordonn\u00e9e (une s\u00e9quence ) mais NON MODIFIABLE . Construction d'un tuple : >>> mon_tuple = ( 5 , 7 , 4 ) Un tuple se diff\u00e9rencie d'une liste par l'utilisation des parenth\u00e8ses . Chaque \u00e9l\u00e9ment du tuple est s\u00e9par\u00e9 par des virgules . >>> type ( mon_tuple ) < class ' tuple '> Remarque : \u00c0 noter qu'un tuple peut \u00eatre d\u00e9clar\u00e9 sans parenth\u00e8ses. C'est toutefois \u00e0 \u00e9viter. >>> taille = 600 , 800 >>> type ( taille ) < class ' tuple '> 3. Acc\u00e8s aux \u00e9l\u00e9ments d'un tuple \u2693\ufe0e Savoir faire L'acc\u00e9s aux \u00e9l\u00e9ments d'un tuple se fait par un indice entre crochets . Les \u00e9l\u00e9ments sont num\u00e9rot\u00e9s de gauche \u00e0 droite \u00e0 partir de 0 . >>> a = ( 12 , 25 , 6 ) >>> a [ 0 ] 12 >>> a [ 2 ] 6 Pour conna\u00eetre le nombre d'\u00e9l\u00e9ments d'un tuple, on peut utiliser la fonction len . >>> t = ( 7 , 5 , 2 , 9 ) >>> len ( t ) 4 On peut \u00e9galement acc\u00e9der aux \u00e9l\u00e9ments par indice n\u00e9gatif. Dans le cas pr\u00e9c\u00e9dent, le dernier \u00e9l\u00e9ment du tuple t est 9 , son indice est 3. >>> t [ 3 ] # acc\u00e9s au dernier \u00e9l\u00e9ment 9 >>> t [ - 1 ] # acc\u00e9s au dernier \u00e9l\u00e9ment par indice n\u00e9gatif 9 L'indice -1 est \u00e9quivalent \u00e0 len(t) - 1 . Comme len(t) vaut 4, 4-1 = 3, ce qui est l'indice du dernier \u00e9l\u00e9ment. 4. Tentative de modification d'un tuple \u2693\ufe0e \u00c0 conna\u00eetre Une fois cr\u00e9\u00e9, un tuple n'est pas modifiable . On dit immutable . On dit que les tuples NE supportent PAS l' affection d'\u00e9l\u00e9ments ou les item assignment . >>> b = ( 9 , 7 , 1 ) >>> b [ 0 ] = 4 --------------------------------------------------------------------------- TypeError Traceback ( most recent call last ) < ipython - input - 7 - 5 fe525706b2b > in < module > () ----> 1 b [ 0 ] = 4 TypeError : 'tuple' object does not support item assignment 5. Parcours d'un tuple \u2693\ufe0e 5.1 Parcours par indice \u2693\ufe0e Savoir faire Pour parcourir les \u00e9l\u00e9ments d'un tuple, on peut utiliser les indices des \u00e9l\u00e9ments (tuple de n \u00e9l\u00e9ments, indice allant de 0 \u00e0 n-1 d'ou l'utilisation de l'it\u00e9rateur range(len(tuple)) ). >>> c = ( 12 , 25 , 6 ) >>> for i in range ( len ( c )): print ( c [ i ]) 12 25 6 5.1 Parcours par \u00e9l\u00e9ment \u2693\ufe0e Savoir faire On peut \u00e9galement parcourir les \u00e9l\u00e9ments directement car un tuple est un it\u00e9rable par d\u00e9finition. >>> for elt in c : print ( elt ) 12 25 6 6. Construction d'une fonction renvoyant un tuple \u2693\ufe0e def division ( a , b ): # fonction renvoyant le tuple (quotient, reste) de la division euclidienne de a par b. q = a // b r = a % b return ( q , r ) >>> division ( 49 , 12 ) ( 4 , 1 )","title":"p-uplet"},{"location":"Types%20construits/p_uplets/cours/#ch5-p-uplets","text":"Programme officiel","title":"CH5 : p-uplets"},{"location":"Types%20construits/p_uplets/cours/#1-les-sequences-en-python","text":"Il est possible de \"stocker\" plusieurs grandeurs dans une m\u00eame structure, ce type de structure est appel\u00e9 une s\u00e9quence . De fa\u00e7on plus pr\u00e9cise, nous d\u00e9finirons une s\u00e9quence comme un ensemble fini et ordonn\u00e9 d'\u00e9l\u00e9ments indic\u00e9s de 0 \u00e0 n-1 si cette s\u00e9quence comporte n \u00e9l\u00e9ments . On \u00e9tudie plus particuli\u00e8rement 2 types de s\u00e9quences : les tuples et les tableaux (il en existe d'autres que nous n'\u00e9voquerons pas ici).","title":"1. Les s\u00e9quences en Python"},{"location":"Types%20construits/p_uplets/cours/#2-definition-des-tuples","text":"\u00c0 savoir Les tuples (appel\u00e9s p-uplets dans le programme officiel de NSI) sont une collection d'objets ordonn\u00e9e (une s\u00e9quence ) mais NON MODIFIABLE . Construction d'un tuple : >>> mon_tuple = ( 5 , 7 , 4 ) Un tuple se diff\u00e9rencie d'une liste par l'utilisation des parenth\u00e8ses . Chaque \u00e9l\u00e9ment du tuple est s\u00e9par\u00e9 par des virgules . >>> type ( mon_tuple ) < class ' tuple '> Remarque : \u00c0 noter qu'un tuple peut \u00eatre d\u00e9clar\u00e9 sans parenth\u00e8ses. C'est toutefois \u00e0 \u00e9viter. >>> taille = 600 , 800 >>> type ( taille ) < class ' tuple '>","title":"2. D\u00e9finition des tuples"},{"location":"Types%20construits/p_uplets/cours/#3-acces-aux-elements-dun-tuple","text":"Savoir faire L'acc\u00e9s aux \u00e9l\u00e9ments d'un tuple se fait par un indice entre crochets . Les \u00e9l\u00e9ments sont num\u00e9rot\u00e9s de gauche \u00e0 droite \u00e0 partir de 0 . >>> a = ( 12 , 25 , 6 ) >>> a [ 0 ] 12 >>> a [ 2 ] 6 Pour conna\u00eetre le nombre d'\u00e9l\u00e9ments d'un tuple, on peut utiliser la fonction len . >>> t = ( 7 , 5 , 2 , 9 ) >>> len ( t ) 4 On peut \u00e9galement acc\u00e9der aux \u00e9l\u00e9ments par indice n\u00e9gatif. Dans le cas pr\u00e9c\u00e9dent, le dernier \u00e9l\u00e9ment du tuple t est 9 , son indice est 3. >>> t [ 3 ] # acc\u00e9s au dernier \u00e9l\u00e9ment 9 >>> t [ - 1 ] # acc\u00e9s au dernier \u00e9l\u00e9ment par indice n\u00e9gatif 9 L'indice -1 est \u00e9quivalent \u00e0 len(t) - 1 . Comme len(t) vaut 4, 4-1 = 3, ce qui est l'indice du dernier \u00e9l\u00e9ment.","title":"3. Acc\u00e8s aux \u00e9l\u00e9ments d'un tuple"},{"location":"Types%20construits/p_uplets/cours/#4-tentative-de-modification-dun-tuple","text":"\u00c0 conna\u00eetre Une fois cr\u00e9\u00e9, un tuple n'est pas modifiable . On dit immutable . On dit que les tuples NE supportent PAS l' affection d'\u00e9l\u00e9ments ou les item assignment . >>> b = ( 9 , 7 , 1 ) >>> b [ 0 ] = 4 --------------------------------------------------------------------------- TypeError Traceback ( most recent call last ) < ipython - input - 7 - 5 fe525706b2b > in < module > () ----> 1 b [ 0 ] = 4 TypeError : 'tuple' object does not support item assignment","title":"4. Tentative de modification d'un tuple"},{"location":"Types%20construits/p_uplets/cours/#5-parcours-dun-tuple","text":"","title":"5. Parcours d'un tuple"},{"location":"Types%20construits/p_uplets/cours/#51-parcours-par-indice","text":"Savoir faire Pour parcourir les \u00e9l\u00e9ments d'un tuple, on peut utiliser les indices des \u00e9l\u00e9ments (tuple de n \u00e9l\u00e9ments, indice allant de 0 \u00e0 n-1 d'ou l'utilisation de l'it\u00e9rateur range(len(tuple)) ). >>> c = ( 12 , 25 , 6 ) >>> for i in range ( len ( c )): print ( c [ i ]) 12 25 6","title":"5.1 Parcours par indice"},{"location":"Types%20construits/p_uplets/cours/#51-parcours-par-element","text":"Savoir faire On peut \u00e9galement parcourir les \u00e9l\u00e9ments directement car un tuple est un it\u00e9rable par d\u00e9finition. >>> for elt in c : print ( elt ) 12 25 6","title":"5.1 Parcours par \u00e9l\u00e9ment"},{"location":"Types%20construits/p_uplets/cours/#6-construction-dune-fonction-renvoyant-un-tuple","text":"def division ( a , b ): # fonction renvoyant le tuple (quotient, reste) de la division euclidienne de a par b. q = a // b r = a % b return ( q , r ) >>> division ( 49 , 12 ) ( 4 , 1 )","title":"6. Construction d'une fonction renvoyant un tuple"},{"location":"Types%20construits/tableaux/cours/","text":"CH7 : Tableaux \u2693\ufe0e Programme officiel","title":"Tableaux"},{"location":"Types%20construits/tableaux/cours/#ch7-tableaux","text":"Programme officiel","title":"CH7 : Tableaux"},{"location":"xtra/end_REM/","text":"Z","title":"end REM"},{"location":"xtra/start_REM/","text":"A","title":"start REM"}]}